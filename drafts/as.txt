*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$                       P E T R O B R A S                                                                                  *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$ Autor    : XZAV - Iran Galdino de Araujo  - Sonda Procwork                                                               *$*$
*$*$ Analista : CFQ7 - Marcelo de Barros Pimentel                                                                             *$*$
*$*$ Início   : 13/04/2010                                                                                                    *$*$
*$*$ Término  : 30/04/2010                                                                                                    *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$                   IDENTIFICAÇÃO DO CÓDIGO                                                                                *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$ Esp.técnica: PM2053  NTI70949-GID5399-09                                                                                 *$*$
*$*$ Finalidade : Relatório de Textos Longos de Notas e Ordens                                                                *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$                 HISTÓRICO DE MODIFICAÇÕES                                                                                *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$ Data       | Autor      | Descrição                                                                                      *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
*$*$ 10.05.11   | ABAPY5SL   | NTI 202258 #: Listagem de medidas de notas ZR com campos adicionais (datas e lote de controle) *$*$
*$*$ 01/12/2011 | ABAPXZFE   | S 5000043167: PM2064-PM2053-Inclu/Vinculo Ord PM às Notas ZR NTI-227414-NTI-221243             *$*$
*$*$ 01/03/2012 | ABAPXZFE   | S 5000047998: Desemvolvimento:PM2053-Inclu/Vinculo YSPM_TEXTOS - Export. Operações             *$*$
*$*$ 21/06/2012 | ABAPXZFE   | S 5000050630: NTI239012-InclVinc. EL PeP ZS ZF Med ZR                                          *$*$
*$*$ 30/07/2012 | abapy7u8   | S 5000052187: INC11395658-Ajuste YSPM_TEXTOS                                                   *$*$
*$*$ 23/01/2013 | abapxzfe   | S 7000000860: Estabilização NTI 239012 YSPM_TEXTOS: INC11395658-Ajuste YSPM_TEXTOS             *$*$
*$*$ 12/04/2013 | ABAPY6HJ   | S 7000002493: INC14414512-Ajuste na YSPM_TEXTOS                                                *$*$
*$*$ 16/11/2016 | ABAPAPN9   | S 7000037252: AD-INC27670051 Incl Cpo Localização                                              *$*$
*$*$ 14/02/2017 | XW37       | S 7000038155: TICKETGD-1486 Restruturação Performance                                          *$*$
*$*$ 17/07/2017 | ABAPBHTV   | S 7000043248: INC000029711532 - Erro YSPM_TEXTOS                                               *$*$
*$*$ 29/08/2017 | ABAPY9HM   | S 7000044268: INC30006057 - Erro YSPM_TEXTOS                                                   *$*$
*$*$ 25/09/2017 | ABAPXZL0   | S 7000044969: INC30163664 - Lentidão YSPM_TEXTOS                                               *$*$
*$*$ 12/12/2018 | ABAPBHTV   | S 7000059731: NTI-227414 Restruturação Performance                                             *$*$
*$*$ 24/01/2019 | ABAPY6IC   | S 7000061017: INC36689874 Correção YSPM_TEXTOS                                                 *$*$
*$*$ 28/04/2019 | ABAPMFP3   | S 7000061017: INC36689874 Correção YSPM_TEXTOS                                                 *$*$
*$*$ 02/07/2019 | ABAPY6IC   | S 7000063703: AS 225028 Melhorias na YSPM_TEXTOS                                               *$*$
*$*$ 02/03/2020 | Y1RA       | S 7000074926: ADI 267209 II DC1821 PM Spt2 YSPM_TEXTOS                                         *$*$
*$*$ 17/04/2020 | Y1RA       | S 7000075356: Estabilização - DC00001821 Sprint 2                                              *$*$
*$*$ 24/04/2020 | Y1RA       | S 7000075475: Estabilização - DC00001821 Sprint 2 (2)                                          *$*$
*$*$ 01/06/2020 | Y1RA       | S 7000076578: INC592704 - YSPM_TEXTOS divergência IW66 - Estab Sprint 2 (3) - Autor da Nota    *$*$
*$*$ 08/06/2020 | Y1RA       | S 7000076812: Estabilização - DC00001821 Sprint 2 (4) - Data da nota                           *$*$
*$*$ 10/08/2021 | ABAPD94R   | S 7000089386:  S4 - Squad Manutenção - PI 2 - Sprint 7                                         *$*$
*$*$ ------------------------------------------------------------------------------------------------------------------------ *$*$
INITIALIZATION.
  DATA: p_obtyp TYPE j_obtyp.   " INICIALIZAÇÃO DE VARIÁVEL MANDATÓRIO PARA SERACHHELP DOS CAMPOS STATUS INCLUSIVO E EXCLUSIVO

  " .................................................
  " Seta a "Variante de Seleção" default, se existir
  " .................................................
  DATA: l_selvariantdefault LIKE rsvar-variant.
  " Obs.: O Padrão SAP considera a Variante de Seleção default como sendo U_ + Nome do Usuário
  CONCATENATE 'U_' sy-uname INTO l_selvariantdefault.

  " Se não tem Variante de Seleção setada (SY-SLSET IS INITIAL), seta a Default.
  " Obs.: As próximas alterações de Variantes de Seleção é gerenciada pelo SAP Standard
  IF sy-slset IS INITIAL.
    CALL FUNCTION 'RS_SUPPORT_SELECTIONS'
      EXPORTING
        report               = sy-repid
        variant              = l_selvariantdefault
      EXCEPTIONS
        variant_not_existent = 01
        variant_obsolete     = 02.
    IF sy-subrc = 02.
      MESSAGE w634(ysf).
    ENDIF.
  ENDIF.

  " .................................................
  " Seta atributos da "Variante de Exibição"
  " .................................................
  gstr_lvaria-report = sy-repid.

  " -------------------------------------------------
  " SelectionScreen PBO Event
  " -------------------------------------------------

  " De acordo com o Tipo de Filtro setado (radiobutton rb_order, rb_note, rb_ope ou  rb_med),
  " seta a visibilidade dos Filtros de Ordem e Nota e os ícones dos pushbuttons de Ordem e Nota
  "Cria botão de ajuda para usuário
  PERFORM yf_cria_icon_help.

*  perform ys_cria_icon_rel.

  push1 = 'Ordem'.
  push2 = 'Notas'.
  push3 = 'Medidas/RTI'.
  push4 = 'Operações'.
  push5 = 'Confirmação'.
  push6 = 'Doc.Medição'.
  push7 = 'Lista de Tarefas'.
  push8 = 'Operações LTa'.
  mytab-prog = sy-repid.
*  mytab-dynnr = 100.
*  mytab-activetab = 'BUTTON1'.
*  sy-ucomm = 'PB_ORDER'.
  CASE mytab-activetab. " sy-ucomm
    WHEN 'PUSH1'.
      mytab-dynnr = 100.
      mytab-activetab = 'PUSH1'.
      sy-ucomm = 'PB_ORDER'.
    WHEN 'PUSH2'.
      mytab-dynnr = 200.
      mytab-activetab = 'PUSH2'.
      sy-ucomm = 'PB_NOTE'.
    WHEN 'PUSH3'.
      mytab-dynnr = 300.
      mytab-activetab = 'PUSH3'.
      sy-ucomm = 'PB_MED'.
    WHEN  'PUSH4'.
      mytab-dynnr = 400.
      mytab-activetab = 'PUSH4'.
      sy-ucomm = 'PB_OPE'.
    WHEN  'PUSH5'.
      mytab-dynnr = 500.
      mytab-activetab = 'PUSH5'.
      sy-ucomm = 'PB_CON'.
    WHEN 'PUSH6'.
      mytab-dynnr = 600.
      mytab-activetab = 'PUSH6'.
      sy-ucomm = 'PB_DOC'.
    WHEN 'PUSH7'.
      mytab-dynnr = 700.
      mytab-activetab = 'PUSH7'.
      sy-ucomm = 'PB_LIS'.
    WHEN 'PUSH8'.
      mytab-dynnr = 800.
      mytab-activetab = 'PUSH8'.
      sy-ucomm = 'PB_TRF'.
  ENDCASE.

AT SELECTION-SCREEN OUTPUT.

  DATA: li_orderfilter_active TYPE i,
        li_notefilter_active  TYPE i,
        li_medfilter_active   TYPE i,
        li_bkgfilter_active   TYPE i,
        li_opefilter_active   TYPE i.
** INÍCIO - 11.08.2021 09:18:18 - ABAPD94R
  DATA: li_confilter_active TYPE i,
        li_docfilter_active TYPE i,
        li_lisfilter_active TYPE i,
        li_trffilter_active TYPE i.
** FIM - 11.08.2021 09:18:18 - ABAPD94R

*Início: PE2K928614 -XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR
*        li_demfilter_active   TYPE i,      " TORNA VISIVEL o GROUP dem  (DEMANDAS)
*        li_dorfilter_active   TYPE i,      " TORNA VISIVEL o GROUP dor  (DEMANDAS + sub-opção 1 Filtro de Ordens que não tenham Nota, Medida)
*        li_dntfilter_active   TYPE i,      " TORNA VISIVEL o GROUP dnt  (DEMANDAS + sub-opção 2 Filtro de Notas que não tenham Medida, Ordem)
*        li_dmefilter_active   TYPE i.      " TORNA VISIVEL o GROUP dme  (DEMANDAS + sub-opção 3 Filtro de Notas e Medidas com Ordens associadas) ATUALMENTE SEM NENHUM FILTRO ESPECÍFICO
*Fim   : PE2K928614 -XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR

** INÍCIO - 10.08.2021 13:58:59 - ABAPD94R


  IF rb_order IS INITIAL AND
     rb_note  IS INITIAL AND
     rb_med   IS INITIAL AND
     rb_ope   IS INITIAL AND
     rb_con   IS INITIAL AND
     rb_doc   IS INITIAL AND
     rb_lis   IS INITIAL AND
     rb_trf   IS INITIAL.
    rb_order = 'X'.
  ENDIF.
  LOOP AT SCREEN.
    IF screen-name EQ 'RB_ORDER' OR
       screen-name EQ 'RB_NOTE' OR
       screen-name EQ 'RB_MED' OR
       screen-name EQ 'RB_OPE' OR
       screen-name EQ 'RB_CON' OR
       screen-name EQ 'RB_DOC' OR
       screen-name EQ 'RB_LIS' OR
       screen-name EQ 'RB_TRF'.

      screen-invisible = '1'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
  LOOP AT SCREEN.
    IF screen-name EQ 'IWERK_O-LOW'.
      screen-required = '2'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

  LOOP AT SCREEN.
    IF screen-name EQ 'QMART_M-LOW'.
      screen-required = '2'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

  LOOP AT SCREEN.
    IF screen-name EQ 'SWERK_M-LOW'.
      screen-required = '2'.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
** FIM - 10.08.2021 13:58:59 - ABAPD94R

  IF rb_order = 'X'.
    p_obtyp = 'ORI'.                                " DEFINIÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO
    EXPORT p_obtyp TO MEMORY ID 'PM_OBTYP'.         " EXPORTAÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO

    li_orderfilter_active = 1.
    pb_order = icon_data_area_expand.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.        " Campos ref a 'execução BACKGROUND' não apresentados para ORDENS
    li_orderfilter_active = 1.
*    " Seta a visibilidade dos campos do Filtro da Ordem
    LOOP AT SCREEN.
      IF screen-group1 = 'ORD'.
        screen-active = li_orderfilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = 'X'.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = ' '.
    rb_lis = ' '.
    rb_trf = ' '.
    mytab-prog = sy-repid.
    mytab-dynnr = 0100.
    mytab-activetab = 'PUSH1'.
    sy-ucomm = 'PB_ORDER'.
  ELSEIF rb_note = 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0200.
    mytab-activetab = 'PUSH2'.
    sy-ucomm = 'PB_NOTE'.
    p_obtyp = 'QMI'.                                " DEFINIÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO
    EXPORT p_obtyp TO MEMORY ID 'PM_OBTYP'.         " EXPORTAÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO

    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 1.
    pb_note = icon_data_area_expand.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_docfilter_active = 0.
    pb_doc = li_docfilter_active = 0.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.        " Campos ref a 'execução BACKGROUND' não apresentados para NOTAS

    LOOP AT SCREEN.
      IF screen-group1 = 'NOT'.
        screen-active = li_notefilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = 'X'.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = ' '.
    rb_lis = ' '.
    rb_trf = ' '.
  ELSEIF rb_med = 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0300.
    mytab-activetab = 'PUSH3'.
    sy-ucomm = 'PB_MED'.
    p_obtyp = 'QA1'.                                " DEFINIÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO
    EXPORT p_obtyp TO MEMORY ID 'PM_OBTYP'.         " EXPORTAÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO

    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 1.
    pb_med = icon_data_area_expand.

    li_opefilter_active = 0.
    pb_ope = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_docfilter_active = 0.
    pb_doc = icon_data_area_collapse.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.        " Campos ref a 'execução BACKGROUND' APRESENTADOS para MEDIDAS

    LOOP AT SCREEN.
      IF screen-group1 = 'MED'.
        screen-active = li_medfilter_active.
        " PARAMETRO INFORMATIVO DA TELA DE SELEÇÃO (SEMPRE DESABILITADO) - "RELAÇÃO MEDIDA X PARTE X CAUSA (1 Causa por Parte da Medida)"
        IF screen-name = 'P_MDP1CA'.
          screen-input = 0.
        ENDIF.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = ' '.
    rb_med = 'X'.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = ' '.
    rb_lis = ' '.
    rb_trf = ' '.
  ELSEIF rb_ope = 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0400.
    mytab-activetab = 'PUSH4'.
    sy-ucomm = 'PB_OPE'.
    p_obtyp = 'OVG'.                                " DEFINIÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO
    EXPORT p_obtyp TO MEMORY ID 'PM_OBTYP'.         " EXPORTAÇÃO MANDATÓRIA PARA USO DO SEARCHHELP DE STATUS INCLUSIVO E EXCLUSIVO

    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_opefilter_active = 1.
    pb_ope = icon_data_area_expand.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_docfilter_active = 0.
    pb_doc = icon_data_area_collapse.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.        " Campos ref a 'execução BACKGROUND' não apresentados para OPERAÇÕES
*    li_opefilter_active = 0.
    LOOP AT SCREEN.
      IF screen-group1 = 'OPE'.
        screen-active = li_opefilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = 'X'.
    rb_con = ' '.
    rb_doc = ''.
    rb_lis = ' '.
    rb_trf = ' '.
  ELSEIF rb_con = 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0500.
    mytab-activetab = 'PUSH5'.
    sy-ucomm = 'PB_CON'.
    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope = icon_data_area_collapse.

    li_docfilter_active = 0.
    pb_doc = icon_data_area_collapse.

    li_confilter_active = 1.
    pb_con = icon_data_area_expand.

    li_docfilter_active = 0.
    pb_doc = icon_data_area_collapse.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.        " Campos ref a 'execução BACKGROUND' não apresentados para OPERAÇÕES

    LOOP AT SCREEN.
      IF screen-group1 = 'CON'.
        screen-active = li_confilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = 'X'.
    rb_doc = ' '.
    rb_lis = ' '.
    rb_trf = ' '.
  ELSEIF rb_doc = 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0600.
    mytab-activetab = 'PUSH6'.
    sy-ucomm = 'PB_DOC'.
    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope =  icon_data_area_collapse.

    li_docfilter_active  = 1.
    pb_doc =  icon_data_area_expand.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.

    LOOP AT SCREEN.
      IF screen-group1 = 'DOC'.
        screen-active = li_docfilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = 'X'.
    rb_lis = ' '.
    rb_trf = ' '.
  ELSEIF rb_lis EQ 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0700.
    mytab-activetab = 'PUSH7'.
    sy-ucomm = 'PB_LIS'.
    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope =  icon_data_area_collapse.

    li_docfilter_active  = 0.
    pb_doc =  icon_data_area_collapse.

    li_lisfilter_active  = 1.
    pb_lis =  icon_data_area_expand.

    li_trffilter_active = 0.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.

    LOOP AT SCREEN.
      IF screen-group1 = 'LIS'.
        screen-active = li_lisfilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.
    rb_order = ' '.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = ' '.
    rb_lis = 'X'.
    rb_trf = ' '.
  ELSEIF rb_trf EQ 'X'.
    mytab-prog = sy-repid.
    mytab-dynnr = 0800.
    mytab-activetab = 'PUSH8'.
    sy-ucomm = 'PB_TRF'.

    li_orderfilter_active = 0.
    pb_order = icon_data_area_collapse.

    li_notefilter_active = 0.
    pb_note = icon_data_area_collapse.

    li_medfilter_active = 0.
    pb_med = icon_data_area_collapse.

    li_confilter_active = 0.
    pb_con = icon_data_area_collapse.

    li_opefilter_active = 0.
    pb_ope =  icon_data_area_collapse.

    li_docfilter_active  = 0.
    pb_doc =  icon_data_area_collapse.

    li_lisfilter_active  = 0.
    pb_lis =  icon_data_area_collapse.

    li_trffilter_active = 1.
    pb_trf = icon_data_area_collapse.

    li_bkgfilter_active = 1.

    LOOP AT SCREEN.
      IF screen-group1 = 'TRF'.
        screen-active = li_trffilter_active.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

    rb_order = ' '.
    rb_note = ' '.
    rb_med = ' '.
    rb_ope = ' '.
    rb_con = ' '.
    rb_doc = ' '.
    rb_lis = ' '.
    rb_trf = 'X'.

  ENDIF.

**    loop at screen.
**      if screen-group1 = 'DOC'.
**        screen-active = 1.
**        modify screen.
**      endif.
**    endloop.
* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*

  LOOP AT SCREEN.
    IF screen-name = 'PB_ORDER' OR
       screen-name = 'PB_NOTE'  OR
       screen-name = 'PB_MED'   OR
       screen-name = 'PB_OPE'   OR
       screen-name = 'PB_CON'   OR
       screen-name = 'PB_DOC'   OR
       screen-name = 'PB_LIS'   OR
       screen-name = 'PB_TRF'.
      screen-active = 0.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
  " Seta a visibilidade dos campos do Filtro da Ordem
**  loop at screen.
**    if screen-group1 = 'ORD'.
**      screen-active = li_orderfilter_active.
**      modify screen.
**    endif.
**  endloop.

  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*  " Importante: Não há nenhum campo do filtro definido para o grupo 'DOD'
*  " é ordem não é demanda não é 3o. Filtro
*  IF ( li_orderfilter_active = 1 AND
*       li_demfilter_active   = 0 AND
*       li_dmefilter_active   = 0 ) OR
*  "      é Nota     é demanda      é 3o. Filtro
*     ( li_medfilter_active   = 1 AND
*       li_demfilter_active   = 1 AND
*       li_dmefilter_active   = 1 ).
*    LOOP AT SCREEN.
*      IF screen-group1 = 'DOD'.
*        screen-active = 1.
*        MODIFY SCREEN.
*      ENDIF.
*    ENDLOOP.
*  ELSE.
*    LOOP AT SCREEN.
*      IF screen-group1 = 'DOD'.
*        screen-active = 0.
*        MODIFY SCREEN.
*      ENDIF.
*    ENDLOOP.
*  ENDIF.
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

  " Seta a visibilidade dos campos do Filtro da Nota
**  loop at screen.
**    if screen-group1 = 'NOT'.
**      screen-active = li_notefilter_active.
**      modify screen.
**    endif.
**  endloop.

*  Seta a visibilidade dos campos do Filtro da Medida
*  loop at screen.
*    if screen-group1 = 'MED'.
*      screen-active = li_medfilter_active.
**      " PARAMETRO INFORMATIVO DA TELA DE SELEÇÃO (SEMPRE DESABILITADO) - "RELAÇÃO MEDIDA X PARTE X CAUSA (1 Causa por Parte da Medida)"
*      if screen-name = 'P_MDP1CA'.
*        screen-input = 0.
*      endif.
*      modify screen.
*    endif.
*  endloop.
* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*
*  Seta a visibilidade dos campos do Filtro da Operações
*  loop at screen.
*    if screen-group1 = 'OPE'.
*      screen-active = li_opefilter_active.
*      modify screen.
*    endif.
*  endloop.
* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*

  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
**Início: PE2K928614 -XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR
*  LOOP AT SCREEN.
*    IF screen-group1 = 'DEM'.
*      screen-active = li_demfilter_active.
*      MODIFY SCREEN.
*    ENDIF.
*  ENDLOOP.
*  LOOP AT SCREEN.
*    IF screen-group1 = 'DOR'.
*      screen-active = li_dorfilter_active.
*      MODIFY SCREEN.
*    ENDIF.
*  ENDLOOP.
*  LOOP AT SCREEN.
*    IF screen-group1 = 'DNT'.
*      screen-active = li_dntfilter_active.
*      MODIFY SCREEN.
*    ENDIF.
*  ENDLOOP.
*  LOOP AT SCREEN.
*    IF screen-group1 = 'DME'.       " ATUALMENTE SEM NENHUM FILTRO ESPECÍFICO
*      screen-active = li_dmefilter_active.
*      MODIFY SCREEN.
*    ENDIF.
*  ENDLOOP.
**Fim: PE2K928614 -XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

  LOOP AT SCREEN.
    IF screen-group1 = 'BKG'.
      screen-active = 1."li_bkgfilter_active.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

** INÍCIO - 11.08.2021 09:55:14 - ABAPD94R
*  loop at screen.
*    if screen-group1 = 'CON'.
*      screen-active = li_confilter_active.
*      modify screen.
*    endif.
*  endloop.

*  loop at screen.
*    if screen-group1 = 'DOC'.
*      screen-active = li_docfilter_active.
*      modify screen.
*    endif.
*  endloop.
** FIM - 11.08.2021 09:55:14 - ABAPD94R

  " -------------------------------------------------
  " SelectionScreen Exit Event
  " -------------------------------------------------

AT SELECTION-SCREEN ON EXIT-COMMAND.
  " Obs.: A SELEÇÃO DE VARIANT DISPARA ESTE EVENTO

  " -------------------------------------------------
  " SelectionScreen Field F4 Event (SearchHelp)
  " -------------------------------------------------

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_o.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_o = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Ordens' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
      gstr_lvaria-variant = ''.             " Abapf1pp amss 25/08/2025

    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_n.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_n = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Notas' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_m.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_m = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Medidas/RTIs' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.

* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_p.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_p = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Operações' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.

** INÍCIO - 25.08.2021 10:45:00 - ABAPD94R
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_c.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_c = gstr_lvaria-variant.
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.


AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_lvar_d.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      p_lvar_d = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Notas' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR variant.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      variant = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Notas' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR variantt.
  " Apresenta o SearchHelp de 'Variante de Exibição'
  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gstr_lvaria
      i_save     = 'A'
    IMPORTING
      es_variant = gstr_lvaria
    EXCEPTIONS
      not_found  = 2.
  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF gstr_lvaria-variant IS NOT INITIAL.
      variantt = gstr_lvaria-variant.       " Define o valor do novo Layout para 'Notas' selecionado no matchcode
    ELSE.
      gstr_lvaria-report = sy-repid.        " Seta novamente o report, pois em caso de "ESC/Cancel" todos os dados da variante são limpos
    ENDIF.
  ENDIF.
** FIM - 25.08.2021 10:45:00 - ABAPD94R

* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*
  " -------------------------------------------------
  " SelectionScreen Field Validation Event
  " -------------------------------------------------

AT SELECTION-SCREEN ON p_lvar_o.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  " Define a variante de exibição informada no Tipo de relatório Ordens e se tiver preenchida verifica sua existência
  IF rb_order = abap_true.
    gstr_lvaria-variant = p_lvar_o.

    IF p_lvar_o IS NOT INITIAL.
      " Verifica se a Variante de Exibição informada existe
      CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
        EXPORTING
          i_save        = 'A'
        CHANGING
          cs_variant    = gstr_lvaria
        EXCEPTIONS
          wrong_input   = 1
          not_found     = 2
          program_error = 3
          OTHERS        = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON p_lvar_n.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  " Define a variante de exibição informada no Tipo de relatório Notas e se tiver preenchida verifica sua existência
  IF rb_note = abap_true.
    gstr_lvaria-variant = p_lvar_n.

    IF p_lvar_n IS NOT INITIAL.
      " Verifica se a Variante de Exibição informada existe
      CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
        EXPORTING
          i_save        = 'A'
        CHANGING
          cs_variant    = gstr_lvaria
        EXCEPTIONS
          wrong_input   = 1
          not_found     = 2
          program_error = 3
          OTHERS        = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON p_lvar_m.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  " Define a variante de exibição informada no Tipo de relatório Medidas/RTIs e se tiver preenchida verifica sua existência
  IF rb_med = abap_true.
    gstr_lvaria-variant = p_lvar_m.

    IF p_lvar_m IS NOT INITIAL.
      " Verifica se a Variante de Exibição informada existe
      CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
        EXPORTING
          i_save        = 'A'
        CHANGING
          cs_variant    = gstr_lvaria
        EXCEPTIONS
          wrong_input   = 1
          not_found     = 2
          program_error = 3
          OTHERS        = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON p_lvar_p.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  " Define a variante de exibição informada no Tipo de relatório Operações e se tiver preenchida verifica sua existência
  IF rb_ope = abap_true.
    gstr_lvaria-variant = p_lvar_p.

    IF p_lvar_p IS NOT INITIAL.
      " Verifica se a Variante de Exibição informada existe
      CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
        EXPORTING
          i_save        = 'A'
        CHANGING
          cs_variant    = gstr_lvaria
        EXCEPTIONS
          wrong_input   = 1
          not_found     = 2
          program_error = 3
          OTHERS        = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
  ENDIF.

** INÍCIO - 25.08.2021 10:47:23 - ABAPD94R
AT SELECTION-SCREEN ON p_lvar_c.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................

  IF rb_con = abap_true.
    gstr_lvaria-variant = p_lvar_c.

    IF p_lvar_c IS NOT INITIAL.
      " Verifica se a Variante de Exibição informada existe
      CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
        EXPORTING
          i_save        = 'A'
        CHANGING
          cs_variant    = gstr_lvaria
        EXCEPTIONS
          wrong_input   = 1
          not_found     = 2
          program_error = 3
          OTHERS        = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
  ENDIF.


AT SELECTION-SCREEN ON p_lvar_d.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  gstr_lvaria-variant = p_lvar_d.

  IF p_lvar_d IS NOT INITIAL.
    " Verifica se a Variante de Exibição informada existe
    CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
      EXPORTING
        i_save        = 'A'
      CHANGING
        cs_variant    = gstr_lvaria
      EXCEPTIONS
        wrong_input   = 1
        not_found     = 2
        program_error = 3
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
** FIM - 25.08.2021 10:47:23 - ABAPD94R

*lista de tarefa
AT SELECTION-SCREEN ON variant.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  gstr_lvaria-variant = variant.

  IF variant IS NOT INITIAL.
    " Verifica se a Variante de Exibição informada existe
    CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
      EXPORTING
        i_save        = 'A'
      CHANGING
        cs_variant    = gstr_lvaria
      EXCEPTIONS
        wrong_input   = 1
        not_found     = 2
        program_error = 3
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON variantt.
  " .................................................
  " Verificação de Variante de Exibição
  " .................................................
  gstr_lvaria-variant = variantt.

  IF variantt IS NOT INITIAL.
    " Verifica se a Variante de Exibição informada existe
    CALL FUNCTION 'REUSE_ALV_VARIANT_EXISTENCE'
      EXPORTING
        i_save        = 'A'
      CHANGING
        cs_variant    = gstr_lvaria
      EXCEPTIONS
        wrong_input   = 1
        not_found     = 2
        program_error = 3
        OTHERS        = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR parnr_n-low.
*
  DATA: t_parnr_n TYPE RANGE OF ihpa-parnr.
  DATA: w_parnr_n LIKE LINE OF t_parnr_n.

  DATA: t_parvw_n TYPE RANGE OF ihpa-parvw.
  DATA: w_parvw_n LIKE LINE OF t_parvw_n.

  parvw_n[] = parvw_n[].

  w_parvw_n-low = parvw_n-low.

  DATA: h_repid LIKE sy-repid.

  h_repid = 'RIQMEL20'. "sy-cprog.'

  CALL FUNCTION 'PM_PARTNER_VALUE_REQUEST'
    EXPORTING
      parvw       = w_parvw_n-low
      parnr_imp   = w_parnr_n-low
      repid       = h_repid
      parvw_field = 'PARVW_N-LOW'
    IMPORTING
      parnr_exp   = w_parnr_n-low.

  parnr_n-low  = w_parnr_n-low.

*----------------------------------------------------------

AT SELECTION-SCREEN ON VALUE-REQUEST FOR parnr_n-high.
*
  DATA: t_parnr_n TYPE RANGE OF ihpa-parnr.
  DATA: w_parnr_n LIKE LINE OF t_parnr_n.

  DATA: t_parvw_n TYPE RANGE OF ihpa-parvw.
  DATA: w_parvw_n LIKE LINE OF t_parvw_n.

  parvw_n[] = parvw_n[].

  w_parvw_n-low = parvw_n-low.

  DATA: h_repid LIKE sy-repid.

  h_repid = 'RIQMEL20'. "sy-cprog.'

  CALL FUNCTION 'PM_PARTNER_VALUE_REQUEST'
    EXPORTING
      parvw       = w_parvw_n-low
      parnr_imp   = w_parnr_n-low
      repid       = h_repid
      parvw_field = 'PARVW_N-LOW'
    IMPORTING
      parnr_exp   = w_parnr_n-low.

  parnr_n-high  = w_parnr_n-low.

*----------------------------------------------------------

AT SELECTION-SCREEN ON VALUE-REQUEST FOR parnr_m-low.
*
  DATA: t_parnr_m TYPE RANGE OF ihpa-parnr.
  DATA: w_parnr_m LIKE LINE OF t_parnr_m.

  DATA: t_parvw_m TYPE RANGE OF ihpa-parvw.
  DATA: w_parvw_m LIKE LINE OF t_parvw_m.

  parvw_m[] = parvw_m[].

  w_parvw_m-low = parvw_m-low.

  DATA: h_repid LIKE sy-repid.

  h_repid = 'RIQMEL20'. "sy-cprog.'

  CALL FUNCTION 'PM_PARTNER_VALUE_REQUEST'
    EXPORTING
      parvw       = w_parvw_m-low
      parnr_imp   = w_parnr_m-low
      repid       = h_repid
      parvw_field = 'PARVW_M-LOW'
    IMPORTING
      parnr_exp   = w_parnr_m-low.

  parnr_m-low  = w_parnr_m-low.

*----------------------------------------------------------

AT SELECTION-SCREEN ON VALUE-REQUEST FOR parnr_m-high.
*
  DATA: t_parnr_m TYPE RANGE OF ihpa-parnr.
  DATA: w_parnr_m LIKE LINE OF t_parnr_m.

  DATA: t_parvw_m TYPE RANGE OF ihpa-parvw.
  DATA: w_parvw_m LIKE LINE OF t_parvw_m.

  parvw_m[] = parvw_m[].

  w_parvw_m-low = parvw_m-low.

  DATA: h_repid LIKE sy-repid.

  h_repid = 'RIQMEL20'. "sy-cprog.'

  CALL FUNCTION 'PM_PARTNER_VALUE_REQUEST'
    EXPORTING
      parvw       = w_parvw_m-low
      parnr_imp   = w_parnr_m-low
      repid       = h_repid
      parvw_field = 'PARVW_M-LOW'
    IMPORTING
      parnr_exp   = w_parnr_m-low.

  parnr_m-high  = w_parnr_m-low.

*----------------------------------------------------------
  " ----------------------------------------------------------
  " AT SELECTION-SCREEN Event para validação global de campos
  " ----------------------------------------------------------

AT SELECTION-SCREEN.

*  case sy-dynnr.
*    when 1000.
  CASE  sy-ucomm.
    WHEN 'PUSH1'.
      mytab-dynnr = 0100.
      mytab-activetab = 'PUSH1'.
      sy-ucomm = 'PB_ORDER'.
    WHEN 'PUSH2'.
      mytab-dynnr = 0200.
      mytab-activetab = 'PUSH2'.
      sy-ucomm = 'PB_NOTE'.
    WHEN 'PUSH3'.
      mytab-dynnr = 0300.
      mytab-activetab = 'PUSH3'.
      sy-ucomm = 'PB_MED'.
    WHEN  'PUSH4'.
      mytab-dynnr = 0400.
      mytab-activetab = 'PUSH4'.
      sy-ucomm = 'PB_OPE'.
    WHEN  'PUSH5'.
      mytab-dynnr = 0500.
      mytab-activetab = 'PUSH5'.
      sy-ucomm = 'PB_CON'.
    WHEN 'PUSH6'.
      mytab-dynnr = 0600.
      mytab-activetab = 'PUSH6'.
      sy-ucomm = 'PB_DOC'.
    WHEN 'PUSH7'.
      mytab-dynnr = 0700.
      mytab-activetab = 'PUSH7'.
      sy-ucomm = 'PB_LIS'.
    WHEN 'PUSH8'.
      mytab-dynnr = 0800.
      mytab-activetab = 'PUSH8'.
      sy-ucomm = 'PB_TRF'.
  ENDCASE.
*    when 100.
*      message s888(sabapdemos) with text-040 sy-dynnr.
*    when 200.
*      message s888(sabapdemos) with text-040 sy-dynnr.
*  endcase.

  "Chama tela de help para usuário
* PERFORM yf_funcao_help.
  PERFORM obter_ajuda CHANGING wc_doc wc_root.

  " Se botão da Ordem foi pressionado, seta o respectivo radiobutton e retorna
  IF sy-ucomm = 'PB_ORDER' OR sy-ucomm = 'PUSH1'.
    rb_order = 'X'.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.

  " Se botão da Nota foi pressionado, seta o respectivo radiobutton e retorn
  IF sy-ucomm = 'PB_NOTE' OR sy-ucomm = 'PUSH2'.
    rb_order = ' '.
    rb_note  = 'X'.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.

  " Se botão da Medida foi pressionado, seta o respectivo radiobutton e retorn
  IF sy-ucomm = 'PB_MED'  OR sy-ucomm = 'PUSH3'.
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = 'X'.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.
  " Se botão da Medida foi pressionado, seta o respectivo radiobutton e retorn
  IF sy-ucomm = 'PB_OPE' OR sy-ucomm = 'PUSH4'.
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = 'X'.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.


  IF sy-ucomm = 'PB_CON' OR sy-ucomm = 'PUSH5'.
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = 'X'.
    rb_doc   = ' '.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.
  IF sy-ucomm = 'PB_DOC'  OR sy-ucomm = 'PUSH6'..
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = 'X'.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.
  IF sy-ucomm = 'PB_LIS'  OR sy-ucomm = 'PUSH7'.
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_lis   = 'X'.
    rb_trf   = ' '.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.
  IF sy-ucomm = 'PB_TRF'  OR sy-ucomm = 'PUSH8'.
    rb_order = ' '.
    rb_note  = ' '.
    rb_med   = ' '.
    rb_ope   = ' '.
    rb_con   = ' '.
    rb_doc   = ' '.
    rb_lis   = ' '.
    rb_trf   = 'X'.
    " rb_dem = ' '.           " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    EXIT.
  ENDIF.
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
  " Se botão da Medida foi pressionado, seta o respectivo radiobutton e retorn
*  IF sy-ucomm = 'PB_DEM'.
*    rb_order = ' '.
*    rb_note = ' '.
*    rb_med = ' '.
*    rb_ope = ' '.
*    rb_dem = 'X'.
*    EXIT.
*  ENDIF.
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*
  " Se botão da Operações foi pressionado, seta o respectivo radiobutton e retorn

  IMPORT wc_origem FROM MEMORY ID 'PEDK9A4U7G'.

  IF  wc_origem = 'X' AND rb_ope = 'X'. "passou pelas ordens

*   Indica que passou por ordens
    wc_origem = ' '.
    EXPORT wc_origem TO MEMORY ID 'PEDK9A4U7G'.

    DATA: v_ans TYPE c VALUE ' '.

    CALL FUNCTION 'POPUP_TO_CONFIRM_STEP' ##FM_OLDED
      EXPORTING
        defaultoption  = 'N'
        textline1      = TEXT-239 "'Utilizar os parâmetros de seleção da tela,'
        textline2      = TEXT-240 "'referente a seleção de Ordens ?'
        titel          = TEXT-241 "'Alerta!'
        cancel_display = ' '
      IMPORTING
        answer         = v_ans.

    IF v_ans EQ 'J'.
*       Ordem
      aufnr_o   = so_aufnr.
      aufnr_o[] = so_aufnr[].
*     Tipo de ordem
      auart_o   = so_auart.
      auart_o[] = so_auart[].
*     Local de instalação
      tplnr_o   = so_tplnr.
      tplnr_o[] = so_tplnr[].
*     Equipamento
      equnr_o   = so_equnr.
      equnr_o[] = so_equnr[].
*     Data de referência
      datuv_o = datuv.
      datub_o = datub.
*     Centro de planejamento
      iwerk_o   = so_iwerk.
      iwerk_o[] = so_iwerk[].
    ENDIF.
  ENDIF.
* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*

  " Se teclou nos radiobuttons
  IF sy-ucomm = 'RB_SELEC' OR gv_screen_3000 EQ 'X'.
    EXIT.
  ENDIF.

  IF sy-ucomm = 'ONLI'.
    sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.
    EXPORT '   ' TO MEMORY ID 'PM_OBTYP'.
  ENDIF.

  " Validação dos campos da SelectionScreen
*  if sy-uname <> 'XZAW'.
  PERFORM f_sscrvalidation.
*  endif.
*  klassenselektion techn. platz (nur bei arbeitsplan für tp)
  IF sy-ucomm = 'TPCL' AND pn_iflo = 'X'.
    SELECT * FROM tcla WHERE obtab = 'IFLOT'.           "#EC CI_NOORDER
      EXIT.                                             "#EC CI_NOORDER
    ENDSELECT.

    CALL FUNCTION 'CLSC_SELECT_OBJECTS_FROM_CLASS'
      EXPORTING
        klart   = tcla-klart
        table   = 'IFLOT'
      TABLES
        objects = clobj_tab
      EXCEPTIONS
        pf03    = 01
        pf12    = 02
        pf15    = 03.

    LOOP AT clobj_tab.
      CLEAR pn_strno.
      pn_strno-option = 'EQ'.
      pn_strno-sign   = 'I'.
      g_tplnr = clobj_tab-obj.               "#EC CI_FLDEXT_OK[2215424]
      WRITE g_tplnr TO pn_strno-low.   "Konv.exit berücksichtigen
      APPEND pn_strno.
    ENDLOOP.
  ENDIF.
* Klassenselektion Equipment (nur bei Equipmentplan)
  IF sy-ucomm = 'EQCL' AND pn_equi = 'X'.
    CLEAR: pn_equnr[],clobj_tab[].
    SELECT * FROM tcla WHERE obtab = 'EQUI'.
      EXIT.                                             "#EC CI_NOORDER
    ENDSELECT.

    CALL FUNCTION 'CLSC_SELECT_OBJECTS_FROM_CLASS'
      EXPORTING
        klart   = tcla-klart
        table   = 'EQUI'
      TABLES
        objects = clobj_tab
      EXCEPTIONS
        pf03    = 01
        pf12    = 02
        pf15    = 03.

    LOOP AT clobj_tab.
      CLEAR pn_equnr.
      pn_equnr-option = 'EQ'.
      pn_equnr-sign   = 'I'.
      pn_equnr-low    = clobj_tab-obj.       "#EC CI_FLDEXT_OK[2215424]
      APPEND pn_equnr.
    ENDLOOP.
  ENDIF.
  DATA: lt_sel_dtel TYPE  rsseldtel OCCURS 0,
        ls_sel_dtel TYPE  rsseldtel.

  ls_sel_dtel-name = 'PN_EXTID'.                " Feldname
  ls_sel_dtel-kind = 'S'.                       " P  für parameters, S  für select-options
  ls_sel_dtel-datenelment = 'TL_EXTID'.         " Datenelement

  APPEND ls_sel_dtel TO lt_sel_dtel.
  CLEAR: ls_sel_dtel.

  ls_sel_dtel-name = 'PN_HIRTL'.               " Feldname
  ls_sel_dtel-kind = 'P'.                       " P  für parameters, S  für select-options
  ls_sel_dtel-datenelment = 'XHIERTL'.           " Datenelement

  APPEND ls_sel_dtel TO lt_sel_dtel.
  CLEAR: ls_sel_dtel.

  ls_sel_dtel-name = 'ADPSP'.                " Feldname
  ls_sel_dtel-kind = 'S'.                      " P  für parameters, S  für select-options
  ls_sel_dtel-datenelment = 'ADDCOMPARE_CORE'.
  APPEND ls_sel_dtel TO lt_sel_dtel.
  CLEAR: ls_sel_dtel.



  CALL FUNCTION 'SELECTION_TEXTS_MODIFY_DTEL'
    EXPORTING
      program                     = sy-repid        " Programmname
    TABLES
      sel_dtel                    = lt_sel_dtel
    EXCEPTIONS
      program_not_found           = 1
      program_cannot_be_generated = 2
      OTHERS                      = 3.
  IF sy-subrc <> 0.

  ENDIF.

  SELECT SINGLE * FROM t370a WHERE tcode = g_tcode.
  IF sy-subrc <> 0.
    SELECT SINGLE * FROM t370a WHERE tcode = 'IA09'.
    IF sy-subrc <> 0.
      MESSAGE x160 WITH 'IA09'.
    ENDIF.
  ENDIF.
  g_aktyp = t370a-aktyp.

  " -------------------------------------------------
  " START-OF-SELECTION Event
  " -------------------------------------------------

START-OF-SELECTION.

  " Define os valores default das vars globais de execução ON-LINE/BACKGROUND, BACKGROUND POR SPOOL/PLANILHA e POR PLANILHA COM/SEM TEXTO LONGO
  " [Cenário de exportação VIA EXECUÇÃO ON-LINE (POR PLANILHA) e SEM TEXTO LONGO]
  gv_export_online_or_backgrd   = abap_true.    " Exportação VIA EXECUÇÃO ON-LINE (TRUE)          [Obrigatoriamente VIA EXECUÇÃO ON-LINE será POR PLANILHA]
  gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação BACKGROUND POR PLANILHA (FALSE)      [inócuo VIA EXECUÇÃO ON-LINE, pois nesse caso será sempre POR PLANILHA]
  gv_export_wsheet_ltext        = abap_false.   " Exportação POR PLANILHA SEM TEXTO LONGO (FALSE)

  " Apresenta o "progress indicator" com uma mensagem
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      percentage = 25
      text       = TEXT-017.

  " Se for execução BACKGROUND
  IF sy-batch = abap_true OR sy-ucomm = 'SJOB'.
    gv_export_online_or_backgrd = abap_false.      " Exportação VIA EXECUÇÃO BACKGROUND (FALSE)
  ENDIF.

  " ............................................................................................................
  " Configuração do FieldCatalog (manter obrigatoriamente no evento START-OF-SELECTION)
  " ............................................................................................................
  PERFORM f_setup_fieldcatalog.

  " ............................................................................................................
  " Configuração do Layout (Sort, Group, Layout, Print) (manter obrigatoriamente no evento START-OF-SELECTION)
  " ............................................................................................................
  PERFORM f_setup_layout_plus.

*-----------------------------------------------------------------------------------------------*
* 02/07/2019 | ABAPY6IC | S 7000063703: AS 225028 -  Melhorias na YSPM_TEXTOS           * inicio*
*-----------------------------------------------------------------------------------------------*
  " =============================================================================================================================================================
  " Busca os dados acordo com os dados informados na tela de filtro de acordo com o Tipo de Filtro setado (radiobutton rb_order, rb_note ou rb_med, rb_dem)
  " =============================================================================================================================================================
  " ..........................................................................
  " ORDENS ou Demandas:ORDENS sem Nota e sem Medida (dy_dor)
  " ..........................................................................
  IF ( rb_order = 'X' ). " OR ( rb_dem = 'X' AND dy_dor = 'X' ).                " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    gv_typereport_name = TEXT-604.
    PERFORM f_sscrgetdata_order.                        "#EC CI_NOORDER

    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.                "#EC CI_NOORDER
      ENDIF.
      " Se não existem dados para os parâmetros selecionados, emite mensagem
    ELSE.
      IF gcol_orderout[] IS INITIAL.
        MESSAGE s047(ih).
        RETURN.
      ENDIF.
    ENDIF.

*    if sy-batch = abap_true or sy-ucomm = 'SJOB'.
*      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.
*    endif.

    " ..........................................................................
    " NOTAS ou Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)
    " ..........................................................................
  ELSEIF ( rb_note = 'X' ). " OR ( rb_dem = 'X' AND  dy_dnt = 'X' ).            " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    gv_typereport_name = TEXT-605.
    PERFORM f_sscrgetdata_note.

    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.



    ELSE.
      " Se não existem dados para os parâmetros selecionados, emite mensagem
      IF gcol_noteout[] IS INITIAL.
        MESSAGE s047(ih).
        RETURN.
      ENDIF.
    ENDIF.
*    if sy-batch = abap_true or sy-ucomm = 'SJOB'.
*      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.
*    endif.

    " ..........................................................................
    " MEDIDAS ou Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
    " ..........................................................................
  ELSEIF ( rb_med = 'X' ). " OR ( rb_dem = 'X' AND dy_dme = 'X' ).              " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    gv_typereport_name = TEXT-606.
    PERFORM f_sscrgetdata_med.

    " Se for cenário de exportação VIA EXECUÇÃO BACKGROUND (gv_export_online_or_backgrd = ABAP_FALSE), realiza execução adicional para exportação
    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      " Se for cenário de exportação VIA EXECUÇÃO BACKGROUND e POR PLANILHA [gv_export_bkg_spool_or_wsheet = ABAP_FALSE]
      " realiza a execução adicional para exportar os dados para planilha e enviar por e-mail
      " Obs.: SENÃO, se for cenário de exportação VIA EXECUÇÃO BACKGROUND e POR SPOOL [gv_export_bkg_spool_or_wsheet = ABAP_TRUE]
      "       a execução é realizada normalmente sem NENHUMA EXECUÇÃO ADICIONAL
      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.

      " SENÃO, se for cenário de exportação VIA EXECUÇÃO ON-LINE (gv_export_online_or_backgrd = ABAP_TRUE)
    ELSE.
      " Se não existem dados para os parâmetros selecionados, emite mensagem
      IF gcol_medout[] IS INITIAL.
        MESSAGE s047(ih).
        RETURN.
      ENDIF.
    ENDIF.

    " ..........................................................................
    " OPERAÇÕES
    " ..........................................................................
  ELSEIF rb_ope = 'X'.
    gv_typereport_name = TEXT-607.
    PERFORM f_sscrgetdata_ope.                          "#EC CI_NOORDER

    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.                "#EC CI_NOORDER
      ENDIF.
    ELSE.
      " Se não existem dados para os parâmetros selecionados, emite mensagem
      IF gcol_operacoesout[] IS INITIAL.
        MESSAGE s047(ih).
        RETURN.
      ENDIF.
    ENDIF.
*    if sy-batch = abap_true or sy-ucomm = 'SJOB'.
*      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.
*    endif.

** INÍCIO - 11.08.2021 10:57:30 - ABAPD94R
    " ..........................................................................
    " CONFIRMAÇÃO
    " ..........................................................................
  ELSEIF rb_con = 'X'.
    gv_typereport_name = TEXT-609.
    PERFORM f_sscrgetdata_con.

    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.

    ELSE.
      " Se não existem dados para os parâmetros selecionados, emite mensagem
      IF gcol_confirmacaoout[] IS INITIAL.
        MESSAGE s047(ih).
        RETURN.
      ENDIF.
    ENDIF.
** FIM - 11.08.2021 10:57:30 - ABAPD94R
  ELSEIF rb_doc = 'X'.
    gv_typereport_name = TEXT-611.
*    perform f_sscrgetdata_con.
    PERFORM f_busca_dados_doc.
    gv_doc = 'X'.
    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.
    ENDIF.
  ELSEIF rb_lis = 'X'.
    gv_typereport_name = TEXT-626.
    PERFORM f_sscrgetdata_lis.

    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.
    ENDIF.
  ELSEIF rb_trf EQ 'X'.
    gv_typereport_name = TEXT-627.
    PERFORM f_sscrgetdata_trf.
    IF gcol_trfout[] IS INITIAL.
      MESSAGE s641(ysf).
      RETURN.
    ENDIF.
    IF gv_export_online_or_backgrd = abap_false.
      sy-cprog = 'YSRPM_ORDER_NOTE_MED_TXT'.

      " Define as var globais de exportação para o cenário de exportação VIA EXECUÇÃO BACKGROUND
      IF rb_spoo = 'X'.                               " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR SPOOL e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_true.    " Exportação POR SPOOL (TRUE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht1 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e SEM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_false.   " Exportação SEM TEXTO LONGO (FALSE)
      ELSEIF rb_wsht2 = 'X'.                          " [Cenário de exportação VIA EXECUÇÃO BACKGROUND, POR PLANILHA e COM TEXTO LONGO]
        gv_export_bkg_spool_or_wsheet = abap_false.   " Exportação POR PLANILHA (FALSE)
        gv_export_wsheet_ltext        = abap_true.    " Exportação COM TEXTO LONGO (TRUE)
      ENDIF.

      IF gv_export_bkg_spool_or_wsheet = abap_false.
        PERFORM f_run_background_wsheet.
      ENDIF.
    ENDIF.
  ENDIF.
*-----------------------------------------------------------------------------------------------*
* 02/07/2019 | ABAPY6IC | S 7000063703: AS 225028 -  Melhorias na YSPM_TEXTOS           * Fim   *
*-----------------------------------------------------------------------------------------------*
* PM NTI-227414 - fasky - abapxzfe----------------------------------------------*
  " Apresenta o "progress indicator" com uma mensagem
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      percentage = 50
      text       = TEXT-017.

  " Apresenta a ALVGrid com os dados retornados
  CALL SCREEN 2000.

END-OF-SELECTION.


  " -------------------------------------------------
  " SelectionScreen Validation Form
  " -------------------------------------------------
*&---------------------------------------------------------------------*
*&      Form  f_SSCRValidation
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_sscrvalidation.

  DATA vl_datediff TYPE p.                                  "7000059731

  " ===============================================================================================================================
  " Valida os respectivos campos do Filtro de acordo com o Tipo de Filtro setado (radiobutton rb_order, rb_note ou rb_med, rb_dem)
  " ===============================================================================================================================
  " ..........................................................................
  " ORDENS ou Demandas:ORDENS sem Nota e sem Medida (dy_dor)
  " ..........................................................................
  IF ( rb_order = 'X' ). " OR ( rb_dem = 'X' AND dy_dor = 'X' ).                " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    IF dy_ofn IS INITIAL AND dy_iar IS INITIAL AND dy_mab IS INITIAL.
      SET CURSOR FIELD 'DY_OFN'.
      MESSAGE e000(ysf) WITH TEXT-022.
    ENDIF.

    IF so_auart IS INITIAL.
      SET CURSOR FIELD 'AUART-LOW'.
      MESSAGE e063(ys_pm) WITH TEXT-018.
    ENDIF.

    IF so_iwerk IS INITIAL.
      SET CURSOR FIELD 'SO_IWERK-LOW'.
      MESSAGE e063(ys_pm) WITH TEXT-019.
    ENDIF.

    " ..........................................................................
    " NOTAS ou Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)
    " ..........................................................................
  ELSEIF ( rb_note = 'X' ). " OR ( rb_dem = 'X' AND dy_dnt = 'X' ).             " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    IF dy_ofn_n IS INITIAL AND dy_rst_n IS INITIAL AND dy_iar_n IS INITIAL AND dy_mab_n IS INITIAL.
      SET CURSOR FIELD 'DY_OFN_N'.
      MESSAGE e000(ysf) WITH TEXT-023.
    ENDIF.

    IF qmart IS INITIAL.
      SET CURSOR FIELD 'QMART-LOW'.
      MESSAGE e063(ys_pm) WITH TEXT-020.
    ENDIF.

    IF swerk_n IS INITIAL.
      SET CURSOR FIELD 'SWERK_N-LOW'.
      MESSAGE e063(ys_pm) WITH TEXT-021.
    ENDIF.


    " ..........................................................................
    " MEDIDAS ou Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
    " ..........................................................................
  ELSEIF ( rb_med = 'X'). " OR ( rb_dem = 'X' AND dy_dme = 'X' ).               " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    IF qmart_m IS INITIAL.
      SET CURSOR FIELD 'QMART_M-LOW'.
      MESSAGE e063(ys_pm) WITH TEXT-020.
    ENDIF.

** INÍCIO - 10.08.2021 14:22:12 - ABAPD94R
    " Centro localização (Nota)
    IF swerk_m IS INITIAL.
      SET CURSOR FIELD 'SWERK_M-LOW'.
      MESSAGE e063(ys_pm) WITH 'Centro localização (Nota)'.
    ENDIF.
** FIM - 10.08.2021 14:22:12 - ABAPD94R

    " ..........................................................................
    " OPERAÇÕES
    " ..........................................................................
  ELSEIF rb_ope = 'X'.
    IF werks_o-low = '*'.
      SET CURSOR FIELD 'WERKS_O-LOW'.
      MESSAGE e016(ys_pm) WITH TEXT-243.
    ENDIF.

*   Centro de trabalho
    IF  arbpl_o IS INITIAL.
      SET CURSOR FIELD 'ARBPL_O'.
      MESSAGE e063(ys_pm) WITH TEXT-200.
    ENDIF.

** INÍCIO - 10.08.2021 14:21:00 - ABAPD94R
    " Centro planejamento
    IF  iwerk_o IS INITIAL.
      SET CURSOR FIELD 'IWERK_O'.
      MESSAGE e063(ys_pm) WITH 'Centro planejamento'.
    ENDIF.
** FIM - 10.08.2021 14:21:00 - ABAPD94R
  ELSEIF rb_lis = 'X'.
    IF pn_iflo IS INITIAL AND
       pn_equi IS INITIAL AND
       pn_ihan IS INITIAL.
      SET CURSOR FIELD 'pn_iflo'.
      MESSAGE e063(ys_pm) WITH 'Preencher uma Opção'.
    ENDIF.
  ELSEIF rb_trf = 'X'.
    IF pn_iflot IS INITIAL AND
       pn_equit IS INITIAL AND
       pn_ihant IS INITIAL.
      SET CURSOR FIELD 'pn_iflot'.
      MESSAGE e063(ys_pm) WITH 'Preencher uma Opção'.
    ENDIF.
  ENDIF.





ENDFORM.                    "f_SSCRValidation

*&---------------------------------------------------------------------*
*&      Form  f_SSCRGetData_Order
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_sscrgetdata_order.
  DATA: lc_sem_medidas TYPE c LENGTH 1 VALUE 'X'.
  DATA: lc_indice      TYPE sy-tabix.
  DATA: lc_delete      TYPE c LENGTH 1.

  DATA: l_date LIKE sy-datum.                               "7000059731

  DATA: lc_ord_status_line        TYPE bsvx-sttxt,
        lc_ord_userstat_line      TYPE bsvx-sttxt,
        lstr_status_aux           TYPE string,
        lstr_status_syst_user_aux TYPE string.
  "...............................................................
  "   Construção de RANGE de Status da Ordem informados no filtro
  "...............................................................
  " Obs.: A Ordem tem seus Status refletidos no campo AFIH-IPHAS o que permite na tx iw38
  "       que as consultas utilizem esta coluna para seleção de Status informados no filtro (Nota é diferente)
  "       ABER-0 LIB-2 ENTE-3 ENCE-6 MREL-4 (iphas=4 -somente é incluído quando selecionado no filtro #encerrado#)
  RANGES: lr_orderstatus_iphas FOR afih-iphas.

  " aberto: Status CREATED (ABER)
  IF NOT dy_ofn IS INITIAL.
    lr_orderstatus_iphas-low    = c_orderstatus_iphas-created.
    lr_orderstatus_iphas-sign   = 'I'.
    lr_orderstatus_iphas-option = 'EQ'.
    APPEND lr_orderstatus_iphas.
  ENDIF.

  " em procmnto: Status RELEASED (LIB)
  IF NOT dy_iar IS INITIAL.
    lr_orderstatus_iphas-low    = c_orderstatus_iphas-released.
    lr_orderstatus_iphas-sign   = 'I'.
    lr_orderstatus_iphas-option = 'EQ'.
    APPEND lr_orderstatus_iphas.
  ENDIF.

  " encerrado: Status TCOMPLETED (ENTE) or Status CLOSED (ENCE)
  IF NOT dy_mab IS INITIAL.
    lr_orderstatus_iphas-low    = c_orderstatus_iphas-tcompleted.
    lr_orderstatus_iphas-sign   = 'I'.
    lr_orderstatus_iphas-option = 'EQ'.
    APPEND lr_orderstatus_iphas.

    lr_orderstatus_iphas-low    = c_orderstatus_iphas-closed.
    lr_orderstatus_iphas-sign   = 'I'.
    lr_orderstatus_iphas-option = 'EQ'.
    APPEND lr_orderstatus_iphas.

    lr_orderstatus_iphas-low    = c_orderstatus_iphas-eliminated.
    lr_orderstatus_iphas-sign   = 'I'.
    lr_orderstatus_iphas-option = 'EQ'.
    APPEND lr_orderstatus_iphas.
  ENDIF.

  ".........................................................................................................
  "   Construção de RANGE de Datas do período informado no filtro (Data de Referência da Ordem)
  ".........................................................................................................
  " Na iw38 a Data de Referência é a Data de Referência da Ordem (na coluna afih-addat) definida através do Status da Ordem  na lógica de gravação da iw32
  RANGES: lr_order_addat FOR afih-addat.   " Range das datas do período do filtro
  RANGES: lr_order_erdat FOR afih-addat.   " Range das datas do período do filtro

  " Se uma das datas do período foi informada, seta as variáveis de período de acordo com o filtro informado e insere o intervalo no RANGE
  " Senão, se as datas não foram informadas, nada faz. O RANGE ficará vazio e o período não será considerado como filtro no SQL
  IF NOT datuv IS INITIAL OR NOT datub IS INITIAL.
    " Se somente a data final foi informada, seta a data inicial com a data-base do SAP
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Inicio*
*-----------------------------------------------------------------------------------------------*
    IF datuv IS INITIAL AND NOT datub IS INITIAL.
      datuv = '19000101'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datub                     "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '-'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datuv  = l_date.                                      "7000059731
    ENDIF.                                                  "7000059731

    " Se somente a data inicial foi informada, seta a data final com a data-teto do SAP
    IF NOT datuv IS INITIAL AND datub IS INITIAL.
      datub = '99991231'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datuv                     "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '+'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datub = l_date.                                       "7000059731
    ENDIF.                                                  "7000059731

    " Insere o intervalo (BETWEEN = BT) da data inicial e data final
    lr_order_addat-low    = datuv.
    lr_order_addat-high   = datub.
    lr_order_addat-sign   = 'I'.
    lr_order_addat-option = 'BT'.
    APPEND lr_order_addat.
  ENDIF.

  IF NOT so_erdat-low IS INITIAL OR NOT so_erdat-high IS INITIAL.
    " Se somente a data final foi informada, seta a data inicial com a data-base do SAP
    IF so_erdat-low  IS INITIAL AND NOT so_erdat-high IS INITIAL.
      datuv = '19000101'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = so_erdat-high             "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '-'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      so_erdat-low = l_date.                                "7000059731
    ENDIF.                                                  "7000059731

    " Se somente a data inicial foi informada, seta a data final com a data-teto do SAP
    IF NOT so_erdat-low IS INITIAL AND so_erdat-high IS INITIAL.
      datub = '99991231'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = so_erdat-low              "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '+'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      so_erdat-high = l_date.                               "7000059731
    ENDIF.                                                  "7000059731

    " Insere o intervalo (BETWEEN = BT) da data inicial e data final
    lr_order_erdat-low    = datuv.
    lr_order_erdat-high   = datub.
    lr_order_erdat-sign   = 'I'.                            "7000059731
    lr_order_erdat-option = 'BT'.                           "7000059731
    APPEND lr_order_erdat.
  ENDIF.

*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Fim   *
*-----------------------------------------------------------------------------------------------*
  " -----------------------------------------------------------------
  " Seleção de Ordens compatíveis com os dados informados no filtro
  " -----------------------------------------------------------------
  DATA: lcol_order   TYPE TABLE OF ty_order.
  DATA: lstr_order   LIKE LINE OF lcol_order.
  DATA: it_viqmel    TYPE TABLE OF viqmel WITH HEADER LINE.
  DATA: lc_aufnr     TYPE aufnr.

  DATA: ls_ugewrk_aux LIKE riwo00-gewrk,
        ls_uwerk_aux  LIKE riwo00-swerk.

  " ..................................................................................................................................
  " ORDENS (SQL PRINCIPAL)
  " ..................................................................................................................................
  " ### IMPORTANTE ###
  " FAVOR NÃO REFATORAR SEM ALINHAMENTO COM A ÁREA FUNCIONAL DO MÓDULO SAP PM
  " Devido a criticidade da transação é MANDATÓRIO conhecimento do respectivo modelo de dados SAP PM
  " para implementar alterações (visando performance ou não) sem reflexos colaterais indesejados para os usuários finais
  " ..................................................................................................................................
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Inicio*
*-----------------------------------------------------------------------------------------------*
  SELECT
    aufk~mandt
    aufk~aufnr
    afko~prueflos
    aufk~auart
    aufk~autyp           " Categoria de ordem (por ex.: 30)
    aufk~erdat
    afko~lead_aufnr      " Ordem principal
    afko~maufnr          " Ordem Superior, que no caso é uma Sub-ordem
    aufk~vaplz           " Centro de trabalho responsável
*   aufk~vawrk           " Centro relativo ao centro de trabalho
    aufk~ktext
    aufk~ltext
    aufk~werks
    aufk~objnr
    aufk~kostv           " Centro de custo responsável
    aufk~kostl           " Centro de custo (Ordem)
    aufk~yyimpacto_falha " Identificador do Impacto da Falha
    aufk~yytipo_interv   " Identificador do Tipo de Intervenção
    aufk~yynota          " Nota associada
    qmel~qmnum           " Nota da Ordem
    afko~gstrp           " Data-base do início
    afko~gsuzp           " Data-base do início (hora)
    afko~gltrp           " Data-base do fim
    afko~gluzp           " Data-base do fim (hora)
    afko~gstri           " Data início real
    afko~getri           " Fim confirmado da ordem (Qual diferenteça com a afko~gltri  Data real do fim ???)
    afih~priok           " Prioridade
    afih~iwerk           " Centro planejamento
    afih~ingpr           " Grupo de planejamento para serviços cliente e manutenção
    afih~equnr           " Equipamento
    afih~addat           " Data de Referência
    eqkt~eqktx           " Denominação do objeto técnico (Equipamento)
    iloa~tplnr           " Local de Instalação
    iloa~stort           " Localização [Localização da Ordem]
    iloa~beber           " Área operacional
    iflot~tplkz          " Código da estrutura do loc.instalação
    iflotx~pltxt         " Denominação do loc.instalação
    afih~iphas           " Fase de processamento da manutenção
    afih~warpl           " Plano de manutenção (se a ordem tiver plano)
    afih~ilart           " Tipo de atividade de manutenção
    afih~iloan
    mpla~wptxt           " Texto do plano de manutenção
    aufk~aenam
    aufk~aedat
    afko~gltri
    afko~aufnt
    aufk~pspel           "Elemento pep interno
    qmel~arbpl           "Centro de trabalho responsável
    qmel~maknz           "Registros de medidas existentes
    FROM aufk  INNER JOIN afko  ON afko~mandt   = aufk~mandt
                               AND afko~aufnr   = aufk~aufnr
               INNER JOIN afih  ON afih~mandt   = aufk~mandt
                               AND afih~aufnr   = aufk~aufnr
           LEFT OUTER JOIN qmel ON qmel~mandt   = aufk~mandt
                               AND qmel~aufnr   = aufk~aufnr
               INNER JOIN iloa  ON iloa~mandt   = afih~mandt
                               AND iloa~iloan   = afih~iloan
          LEFT OUTER JOIN iflot ON iflot~mandt  = iloa~mandt
                               AND iflot~tplnr  = iloa~tplnr
         LEFT OUTER JOIN iflotx ON iflotx~mandt = iloa~mandt
                               AND iflotx~tplnr = iloa~tplnr
                               AND iflotx~spras = sy-langu
           LEFT OUTER JOIN eqkt ON eqkt~mandt   = afih~mandt
                               AND eqkt~equnr   = afih~equnr
                               AND eqkt~spras   = sy-langu
           LEFT OUTER JOIN mpla ON mpla~mandt   = afih~mandt
                               AND mpla~warpl   = afih~warpl
    APPENDING CORRESPONDING FIELDS OF TABLE lcol_order
    WHERE aufk~aufnr      IN so_aufnr " Ordem
      AND aufk~auart      IN so_auart " Tipo de ordem
      AND iloa~tplnr      IN so_strno " Local de Instalação
      AND iloa~stort      IN so_stort " Localização [Localização da Ordem]
      AND afih~equnr      IN so_equnr " Equipamento
      AND aufk~vaplz      IN so_gewrk " Centro de trabalho responsável
      AND afko~lead_aufnr IN lead_auf
      AND afko~maufnr     IN maufnr
      " AND afko~aufnt      IN aufnrdo  " Campo do filtro ref ao grupo DOR [VISIBLE ONLY=Demandas: Ordens]    " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
      AND afih~iphas      IN lr_orderstatus_iphas
      AND afih~iwerk      IN so_iwerk
      AND afih~ingpr      IN so_ingrp   "Grupo de planej.manutenção ordem
      AND afih~priok      IN so_priok
      AND afih~addat      IN lr_order_addat
      AND aufk~ernam      IN so_ernam
  AND aufk~erdat      IN so_erdat.                      "#EC CI_NOORDER
*  >> 7000038155: TICKETGD-1486 roberto inicio
*      %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
*  >> 7000038155: TICKETGD-1486 roberto fim
  CONSTANTS cc_hints_3 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Fim   *
*-----------------------------------------------------------------------------------------------*

  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*  " ..........................................................................
*  " Demandas:ORDENS sem Nota e sem Medida (dy_dor)
*  " ..........................................................................
** Início: PE2K928614-XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR,
*  IF rb_dem = 'X' AND dy_dor = 'X'.
*    " Se há dados de Ordem para o relatório 'Demandas:ORDENS sem Nota e sem Medida'
*    " remove as Ordens com Nota (lcol_order~qmnum) e remove as Ordens com atribuição a Medida (QMSM-YYAUFNR)
*    IF lcol_order[] IS NOT INITIAL.
*      DELETE lcol_order WHERE qmnum IS NOT INITIAL OR qmnum <> SPACE.
*
*      LOOP AT lcol_order INTO lstr_order.
*        lc_indice = sy-tabix.
*
*        SELECT SINGLE yyaufnr  "Ordem atribuida a Medida
*          INTO lc_aufnr
*          FROM qmsm WHERE yyaufnr = lstr_order-aufnr.
*        IF sy-subrc = 0.
*          DELETE lcol_order INDEX lc_indice.
*        ENDIF.
*      ENDLOOP.
*    ENDIF.
*  ENDIF.
** Fim: PE2K928614-XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR,
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

  " Se não há dados de Ordem, retorna
  IF lcol_order[] IS INITIAL.
    MESSAGE i641(ysf).
    RETURN.
  ENDIF.

  "----------------------------------------------------------------------------------------
  " Seleção de Ordens compatíveis com os filtros indiretos e inclusão na OUTPUT ITable
  "----------------------------------------------------------------------------------------
  RANGES: lr_order_objnr    FOR aufk-objnr.       " Performance para SELECTs
  "..........................................................................
  " Percorre cada Ordem buscando seus Status de Sistema e Usuário
  "..........................................................................
  CLEAR: gcol_orderout.  REFRESH: gcol_orderout.

  LOOP AT lcol_order INTO lstr_order.                   "#EC CI_NOORDER
    IF lstr_order-arbpl IS NOT INITIAL.
      CALL FUNCTION 'CR_WORKSTATION_READ' ##FM_SUBRC_OK
        EXPORTING
          id        = CONV rcr01-arbid( lstr_order-arbpl )
          msgty     = 'S'
        IMPORTING
          arbpl     = ls_ugewrk_aux       " NÃO UTILIZADO
          ktext     = lstr_order-ktext1
          werks     = ls_uwerk_aux        " NÃO UTILIZADO
        EXCEPTIONS
          not_found = 1.
    ELSE.
      CALL FUNCTION 'CR_WORKSTATION_CHECK' ##FM_SUBRC_OK
        EXPORTING
          arbpl     = lstr_order-vaplz
          werks     = lstr_order-iwerk
        IMPORTING
          ktext     = lstr_order-ktext1
        EXCEPTIONS
          not_found = 1.
    ENDIF.

    CALL FUNCTION 'CONVERSION_EXIT_ABPSP_OUTPUT'
      EXPORTING
        input  = lstr_order-pspel
      IMPORTING
        output = lstr_order-posid.

    "..........................................................................
    " Busca e seta os textos de Status de Sistema e Status de Usuário da Ordem
    "..........................................................................
    CALL FUNCTION 'STATUS_TEXT_EDIT'
      EXPORTING
        flg_user_stat    = 'X'
        objnr            = lstr_order-objnr
        spras            = sy-langu
        bypass_buffer    = 'X'
      IMPORTING
        line             = lc_ord_status_line
        user_line        = lc_ord_userstat_line
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    IF sy-subrc EQ 0.
      CLEAR: lstr_status_syst_user_aux.
      CONCATENATE lc_ord_status_line lc_ord_userstat_line INTO lstr_status_syst_user_aux SEPARATED BY space.

      " Filtro 'Status Inclusivo - Ordens'
      IF stai1_or IS NOT INITIAL.
        wc_exit = abap_true.
        LOOP AT stai1_or.
          TRANSLATE stai1_or-low TO UPPER CASE.
          CONCATENATE '*' stai1_or-low '*' INTO lstr_status_aux.
          " Se a Ordem corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Inclusivo, MANTÉM a Ordem (wc_exit = ABAP_FALSE)
          IF lstr_status_syst_user_aux CP lstr_status_aux.
            wc_exit = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF wc_exit = abap_true.
          CONTINUE.
        ENDIF.
      ENDIF.

      " Filtro 'Status Exclusivo - Ordens'
      IF stae1_or IS NOT INITIAL.
        wc_exit = abap_false.
        LOOP AT stae1_or.
          TRANSLATE stae1_or-low TO UPPER CASE.
          CONCATENATE '*' stae1_or-low '*' INTO lstr_status_aux.
          " Se a Ordem corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Exclusivo, IGNORA/REMOVE a Ordem (wc_exit = ABAP_TRUE)
          IF lstr_status_syst_user_aux CP lstr_status_aux.
            wc_exit = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF wc_exit = abap_true.
          CONTINUE.
        ENDIF.
      ENDIF.

      lstr_order-sttxt = lc_ord_status_line.
      lstr_order-ustxt = lc_ord_userstat_line.
      CLEAR: lc_ord_status_line, lc_ord_userstat_line, lstr_status_aux.

    ELSE.
      CLEAR: lstr_order-sttxt, lstr_order-ustxt.
      CONTINUE.
    ENDIF.

    " Inclusão da Ordem selecionada no RANGE de Ordens selecionadas
    lr_order_objnr-low    = lstr_order-objnr.
    lr_order_objnr-sign   = 'I'.
    lr_order_objnr-option = 'EQ'.
    APPEND lr_order_objnr.

    CLEAR:lstr_order-ktext2.
    IF lstr_order-stort IS NOT INITIAL.
      SELECT SINGLE ktext                "#EC CI_NOORDER or "#EC WARNOK
      INTO  lstr_order-ktext2
      FROM t499s
      WHERE stand = lstr_order-stort.
    ENDIF.

    APPEND lstr_order TO gcol_orderout.                 "#EC CI_NOORDER
  ENDLOOP.


  " Se não existem dados na OUTPUT ITable, retorna
  IF gcol_orderout[] IS INITIAL.
    MESSAGE w641(ysf).
    RETURN.
  ENDIF.

  " -----------------------------------------------------------------
  " Seleção de Histórico de Status das Ordens selecionadas
  " -----------------------------------------------------------------
  DATA: lcol_jcds TYPE HASHED TABLE OF jcds WITH UNIQUE KEY primary_key COMPONENTS objnr stat chgnp chgnr,
        lstr_jcds LIKE LINE OF lcol_jcds.

* Início: PE2K928614-XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR,
  SORT lr_order_objnr BY  low.

  DELETE ADJACENT DUPLICATES FROM lr_order_objnr COMPARING low.

  IF lcol_order[] IS NOT INITIAL.
    SELECT *
      APPENDING TABLE lcol_jcds
      FROM jcds
       FOR ALL ENTRIES IN lr_order_objnr
    WHERE jcds~objnr EQ lr_order_objnr-low.
*           %_HINTS ORACLE '&MAX_BLOCKING_FACTOR 50&'       "7000059731
*           ORACLE '&MAX_IN_BLOCKING_FACTOR 50&'.           "7000059731
    CONSTANTS cc_hints_1 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.

  ENDIF.
* Fim:    PE2K928614-XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR,

  "----------------------------------------------------------------------------------------------
  " Preenchimento de dados complementares de cada Ordem selecionada e alteração na OUTPUT ITable
  "----------------------------------------------------------------------------------------------
  DATA: lstr_orderout LIKE LINE OF gcol_orderout,
        lstr_orderaux LIKE LINE OF gcol_orderout,
        li_tabixout   TYPE syst-tabix.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
  SORT lcol_jcds BY objnr ASCENDING
                    stat  ASCENDING
                    udate DESCENDING
                    utime DESCENDING.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM
  ".............................................................................
  " Percorre cada Ordem selecionada preenchendo os dados de Histórico de Status
  ".............................................................................
  LOOP AT gcol_orderout INTO lstr_orderout.
    " Seta OUTPUT ITable Tabix
    li_tabixout = sy-tabix.

    " Busca dados de Histórico de Status para Ordem ABERTA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)

    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-created
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-created_uname     = lstr_jcds-usnam.
      lstr_orderout-created_date      = lstr_jcds-udate.
      lstr_orderout-created_time      = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds "USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-created
          AND chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
*          AND inact IS INITIAL.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-created_uname     = lstr_jcds-usnam.
        lstr_orderout-created_date      = lstr_jcds-udate.
        lstr_orderout-created_time      = lstr_jcds-utime.
        EXIT.
      ENDLOOP.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM
    ENDIF.

    " Busca dados de Histórico de Status para Ordem LIBERADA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

***    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
***                                                                              stat  = c_order_status-released
***                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
***                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.

    READ TABLE lcol_jcds INTO lstr_jcds WITH KEY                              objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-released
                                                                              inact = ' '.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-released_uname    = lstr_jcds-usnam.
      lstr_orderout-released_date     = lstr_jcds-udate.
      lstr_orderout-released_time     = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds "USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-released
                  AND inact IS INITIAL.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-released_uname    = lstr_jcds-usnam.
        lstr_orderout-released_date     = lstr_jcds-udate.
        lstr_orderout-released_time     = lstr_jcds-utime.
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Ordem CONFIRMADA PARCIALMENTE
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

***    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
***                                                                              stat  = c_order_status-partconf
***                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
***                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.

    READ TABLE lcol_jcds INTO lstr_jcds WITH KEY                              objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-partconf
                                                                              inact = ' '.


* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-partconf_uname    = lstr_jcds-usnam.
      lstr_orderout-partconf_date     = lstr_jcds-udate.
      lstr_orderout-partconf_time     = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds "USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-partconf.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-partconf_uname    = lstr_jcds-usnam.
        lstr_orderout-partconf_date     = lstr_jcds-udate.
        lstr_orderout-partconf_time     = lstr_jcds-utime.
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Ordem CONFIRMADA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

***    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
***                                                                              stat  = c_order_status-confirmed
***                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
***                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.

    READ TABLE lcol_jcds INTO lstr_jcds WITH KEY                              objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-confirmed
                                                                              inact = ' '.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-confirmed_uname   = lstr_jcds-usnam.
      lstr_orderout-confirmed_date    = lstr_jcds-udate.
      lstr_orderout-confirmed_time    = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds"USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-confirmed.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-confirmed_uname   = lstr_jcds-usnam.
        lstr_orderout-confirmed_date    = lstr_jcds-udate.
        lstr_orderout-confirmed_time    = lstr_jcds-utime.
        EXIT.
      ENDLOOP.

    ENDIF.

    " Busca dados de Histórico de Status para Ordem ENCERRADA TECNICAMENTE
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    " IMPORTANTE: Foi realizado uma correção emergencial e paliativo APENAS para garantir que seja apresentada a 1a ocorrência dos Status recorrentes (LIB, CNPA, CONF, ENTE, ENCE),
    "             pois apresentava uma determinada data de ocorrência do Status diferente para uma Ordem dependendo da quantidade de ordens apresentadas.
    "             Entretanto, deve ser definido se um Status recorrente (como ENTE) deve ser considerado para o processo
    "             a sua 1a ocorrência ou a sua última ocorrência, bem como se um Status recorrente deve ser considerado se atualmente não está ativo
    "             (por ex.: Ordem LIB no momento que foi anulado ENTE, já tem uma ocorrência no Status)

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

***    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
***                                                                              stat  = c_order_status-tcompleted
***                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
***                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.

    READ TABLE lcol_jcds INTO lstr_jcds WITH KEY                              objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-tcompleted
                                                                              inact = ''.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM


    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-tcompleted_uname  = lstr_jcds-usnam.
      lstr_orderout-tcompleted_date   = lstr_jcds-udate.
      lstr_orderout-tcompleted_time   = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds" USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-tcompleted
                  AND inact IS INITIAL.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-tcompleted_uname  = lstr_jcds-usnam.
        lstr_orderout-tcompleted_date   = lstr_jcds-udate.
        lstr_orderout-tcompleted_time   = lstr_jcds-utime.
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Ordem ENCERRADA COMERCIALMENTE
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)


* Request:S4DK963505

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.

*    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_orderout-objnr
*                                                                              stat  = c_order_status-closed
*                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.

    READ TABLE lcol_jcds INTO lstr_jcds WITH KEY                              objnr = lstr_orderout-objnr
                                                                              stat  = c_order_status-closed
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001
                                                                              inact = ' '.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM


    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_orderout-closed_uname      = lstr_jcds-usnam.
      lstr_orderout-closed_date       = lstr_jcds-udate.
      lstr_orderout-closed_time       = lstr_jcds-utime.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds" USING KEY primary_key
        WHERE objnr = lstr_orderout-objnr
          AND stat  = c_order_status-closed
                  AND inact IS INITIAL.

*          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_orderout-closed_uname      = lstr_jcds-usnam.
        lstr_orderout-closed_date       = lstr_jcds-udate.
        lstr_orderout-closed_time       = lstr_jcds-utime.
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM


    ENDIF.

    " Alteração dos dados da Ordem selecionada na OUTPUT ITable
    MODIFY gcol_orderout INDEX li_tabixout FROM lstr_orderout.

  ENDLOOP.

ENDFORM.                    "f_SSCRGetData_Order

*&---------------------------------------------------------------------*
*&      Form  f_SSCRGetData_Note
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM f_sscrgetdata_note.
  DATA: lc_notif_status_line      TYPE bsvx-sttxt,
        lc_notif_userstat_line    TYPE bsvx-sttxt,
        lstr_status_aux           TYPE string,
        lstr_status_syst_user_aux TYPE string.

  DATA: l_date LIKE sy-datum.                               "7000059731
  DATA: lwa_diadr    TYPE diadr.
  DATA: lc_indice    TYPE sy-tabix.
  "...............................................................
  "   Construção de RANGE de Status da Nota informados no filtro
  "...............................................................
  " Obs.: A Nota (diferentemente de Ordem) NÃO tem seus Status refletidos num campo de acordo com a iw28 paleativamente,
  "       utiliza-se somente para otimizar performance o campo "Data de encerramento da nota" (vide abaixo)
  "       Dessa forma, é necessário que verifiquemos os Status informados no filtro após o SQL principal
  RANGES: lr_note_status FOR jest-stat,
  lr_note_qmdab  FOR qmel-qmdab. " Data de encerramento da nota

  " aberto (Pendente): Status OUTSTANDING (MSPN)
  IF NOT dy_ofn_n IS INITIAL.
    lr_note_status-low    = c_note_status-outstanding.
    lr_note_status-sign   = 'I'.
    lr_note_status-option = 'EQ'.
    APPEND lr_note_status.
  ENDIF.

  " Adiado: Status POSTPONED (MSDI)
  IF NOT dy_rst_n IS INITIAL.
    lr_note_status-low    = c_note_status-postponed.
    lr_note_status-sign   = 'I'.
    lr_note_status-option = 'EQ'.
    APPEND lr_note_status.
  ENDIF.

  " em procmnto: Status INPROCESS (MSPR)
  IF NOT dy_iar_n IS INITIAL.
    lr_note_status-low    = c_note_status-inprocess.
    lr_note_status-sign   = 'I'.
    lr_note_status-option = 'EQ'.
    APPEND lr_note_status.
  ENDIF.

  " encerrado: Status COMPLETED (MSEN)
  " IMPORTANTE: Se o Status "encerrado" NÃO foi setado, para auxiliar a performance da pesquisa via Status,
  "             a tx iw28 Standard utiliza o campo "Data de encerramento da nota" como INITIAL (qmel~qmdab = 00000000)
  "             Dessa forma, o RANGE da "Data de Encerramento da Nota" não será utilizado se o Status "encerrado" for setado
  IF NOT dy_mab_n IS INITIAL.
    lr_note_status-low    = c_note_status-completed.
    lr_note_status-sign   = 'I'.
    lr_note_status-option = 'EQ'.
    APPEND lr_note_status.
  ELSE.
    lr_note_qmdab-low = '00000000'.    " Seta como INITIAL de data (00000000)
    lr_note_qmdab-sign   = 'I'.
    lr_note_qmdab-option = 'EQ'.
    APPEND lr_note_qmdab.
  ENDIF.
  "..........................................................................................
  "   Construção de RANGE de Datas do período informado no filtro (Data de Referência da Nota)
  "..........................................................................................
  " Na iw28 a Data de Referência é a sempre a Data da Nota (coluna qmel-qmdat) definida sempre na iw22 para qualquer Status (diferentemente da Ordem que tem uma lógica para a Data de Referência)
  RANGES: lr_note_qmdat   FOR qmel-qmdat.   " Range das datas do período do filtro
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Inicio*
*-----------------------------------------------------------------------------------------------*

  " Se uma das datas do período foi informada, seta as variáveis de período de acordo com o filtro informado e insere o intervalo no RANGE
  " Senão, se as datas não foram informadas, nada faz. O RANGE ficará vazio e o período não será considerado como filtro no SQL
  IF NOT datuv_n IS INITIAL OR NOT datub_n IS INITIAL.
    " Se somente a data final foi informada, seta a data inicial com a data-base do SAP
    IF datuv_n IS INITIAL AND NOT datub_n IS INITIAL.
      datuv_n = '19000101'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datub_n                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '-'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datuv_n = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731

    " Se somente a data inicial foi informada, seta a data final com a data-teto do SAP
    IF NOT datuv_n IS INITIAL AND datub_n IS INITIAL.
      datub_n = '99991231'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datuv_n                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '+'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datub_n = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Fim   *
*-----------------------------------------------------------------------------------------------*
    " Insere o intervalo (BETWEEN = BT) da data inicial e data final
    lr_note_qmdat-low    = datuv_n.
    lr_note_qmdat-high   = datub_n.
    lr_note_qmdat-sign   = 'I'.
    lr_note_qmdat-option = 'BT'.
    APPEND lr_note_qmdat.
  ENDIF.
  "..........................................................................................
  "   Construção de RANGE por Tipo de Nota
  "..........................................................................................
  " POR PERFORMANCE: Na iw28 o Tipo de Nota mesmo que setado como * no filtro é substituido por um RANGE com todas as Notas de PM (QMTYP = 01) e Notas de Serviço (QMTYP = 03)
  RANGES: lr_note_qmart   FOR qmel-qmart.   " Range de Tipo de Nota
  " Se foi setado * monta um RANGE com todos Tipos de Nota considerados na iw28
  " Senão, o RANGE será o próprio qmart (PARAMETER da SELECTION-SCREEN)

  IF qmart-low = '*' AND qmart-option = 'CP'.
    " Busca Tipos de Nota (tive que colocar as LOW para preencher corretamente o RANGE)
    SELECT qmart AS low
    FROM tq80
    APPENDING CORRESPONDING FIELDS OF TABLE lr_note_qmart
    WHERE tq80~qmtyp IN ('01' , '03').  " Tx iw28 somente são considerados Notas de PM e Notas de Serviço (qmtyp=01, 03)

    " Corrige os parâmetros do RANGE de Tipos de Nota
    LOOP AT lr_note_qmart.
      lr_note_qmart-sign   = 'I'.
      lr_note_qmart-option = 'EQ'.
      MODIFY lr_note_qmart.
    ENDLOOP.
  ELSE.
    lr_note_qmart[] = qmart[].
  ENDIF.

  " -----------------------------------------------------------------
  " Seleção de Notas compatíveis com os dados informados no filtro
  " -----------------------------------------------------------------
  DATA: lcol_note TYPE TABLE OF ty_note.
  DATA: lcol_note_aux TYPE TABLE OF ty_note.
  DATA: lstr_note LIKE LINE OF lcol_note.
  DATA: lc_qmnum LIKE qmel-qmnum.

  DATA: ls_ugewrk_aux LIKE riwo00-gewrk,
        ls_uwerk_aux  LIKE riwo00-swerk.

  " ..................................................................................................................................
  " NOTAS (SQL PRINCIPAL)
  " ..................................................................................................................................
  " ### IMPORTANTE ###
  " FAVOR NÃO REFATORAR SEM ALINHAMENTO COM A ÁREA FUNCIONAL DO MÓDULO SAP PM
  " Devido a criticidade da transação é MANDATÓRIO conhecimento do respectivo modelo de dados SAP PM
  " para implementar alterações (visando performance ou não) sem reflexos colaterais indesejados para os usuários finais
  " ..................................................................................................................................
  SELECT
        qmel~qmnum            " Nº da nota
        qmel~qmart            " Tipo de nota
        qmel~qmdat            " Data da nota
        qmel~aufnr            " Nº ordem
        qmel~qmtxt            " Texto breve
        qmel~objnr            " Nº objeto para administração de status
        qmel~phase            " Fase de processamento nota
        qmel~artpr            " Tipo de prioridade
        qmel~priok            " Prioridade
        qmel~indtx            " Existe texto descritivo para o objeto
        qmel~rbnr             " Perfil de catálogo
        qmel~qmnam            " Autor da Nota
        qmel~erdat            " Data de criação
        qmel~aenam            " Nome do responsável pela modificação do objeto
        qmel~aedat            " Data da última modificação
        qmel~arbpl            " ID-objeto do centro trabalho
        qmel~yyimpacto_falha  " Id Impacto Falha (Nota)  [snapshot do Impacto Falha do Local de Instalação (iflot~yyimpacto_falha) no momento da criação da Nota]
        qmih~ingrp            " Grupo de planejamento para serviços cliente e manutenção
        qmih~iwerk            " Centro planejamento
        iloa~tplnr            " Local de Instalação
        iloa~swerk            " Centro de localização (Nota) [snapshot do Centro de Localização do Local de Instalação (iflot~yycentro ou ILOA-SWERK do próprio Local) no momento da criação da Nota]
        iloa~stort            " Localização [Localização da Nota]
        iloa~abckz            " Código ABC
        iflot~tplkz           " Código da estrutura do loc.instalação
        iflotx~pltxt          " Denominação do loc.instalação
        iflot~yyimpacto_falha AS yyimpacto_falha_local  " Id Impacto Falha (Local)        [vide 'Id Impacto Falha (Nota)']
        iflot~yycentro        AS swerk_local            " Centro de localização (Local)   [vide 'Centro de localização (Nota)']
        qmih~equnr            " Equipamento
        eqkt~eqktx            " Denominação do objeto técnico (Equipamento)
        qmih~warpl            " Plano de manutenção (se a Nota tiver plano)
        mpla~wptxt            " Texto do plano de manutenção
        qmih~bautl            " Conjunto
        iloa~kokrs            " Área de contabilidade de custos
        iloa~kostl            " Centro de custo (Nota)
        iloa~eqfnr            " Campo de seleção
        iloa~beber            " Área operacional
        iloa~proid            " Elemento PEP Interno
        qmel~kunum            " Nº  conta do cliente
        qmel~kzmla            " Código: Segmento de texto em idioma principal
        qmel~adrnr            " Endereços: nº do endereço
        qmih~ausvn            " Início avaria
        qmih~ausbs            " Fim da avaria
        qmih~btpln            " Local instal.afetado
        qmih~bequi            " Equipamento afetado
        qmih~msaus            " Parada
        qmih~auszt            " Duração da parada
        qmih~maueh            " Unidade de tempo para a duração da parada
        qmih~yyareaplan       " Área degradada (m²) -  Abapf1pp - amss - 21/08/2025
        qmih~yyareaexec       " Área pintada (m²) - Abapf1pp - amss - 21/08/2025
        qmih~yyareatipo       " Tipo de área - Abapf1pp - amss - 21/08/2025
        qmel~prueflos         " Lote de Controle
        qmel~qmkat            " Tipo de catálogo da Nota        (NÃO SERÁ APRESENTADO/NÃO ESTÁ NO FIELDCATALOG - SIMILAR A IW28)
        qmel~qmgrp            " Grupo do catálogo da Nota
        qmel~qmcod            " Código do catálogo da Nota
    FROM qmel INNER JOIN qmih ON qmih~mandt   = qmel~mandt
                             AND qmih~qmnum   = qmel~qmnum
              INNER JOIN iloa ON iloa~mandt   = qmih~mandt
                             AND iloa~iloan   = qmih~iloan
        LEFT OUTER JOIN iflot ON iflot~mandt  = iloa~mandt
                             AND iflot~tplnr  = iloa~tplnr
       LEFT OUTER JOIN iflotx ON iflotx~mandt = iloa~mandt
                             AND iflotx~tplnr = iloa~tplnr
                             AND iflotx~spras = sy-langu
        LEFT OUTER JOIN eqkt  ON eqkt~mandt   = qmih~mandt
                             AND eqkt~equnr   = qmih~equnr
                             AND eqkt~spras   = sy-langu
        LEFT OUTER JOIN mpla  ON mpla~mandt   = qmih~mandt
                             AND mpla~warpl   = qmih~warpl
                       APPENDING CORRESPONDING FIELDS OF TABLE lcol_note
    WHERE qmel~qmnum IN qmnum
      AND qmel~qmart IN lr_note_qmart
      AND qmel~qmdat IN lr_note_qmdat
      AND qmel~qmdab IN lr_note_qmdab     " Data de encerramento da nota (vide comentários acima)
      AND iloa~tplnr IN strno_n
      AND iloa~swerk IN swerk_n           " Centro localização (Nota) [vide acima]
      AND iloa~stort IN stort_n           " Localização [Localização da Nota]
      AND iloa~beber IN beber_n           " Área Operacional
      AND qmel~aufnr IN aufnr_n
      AND qmel~qmtxt IN qmtxt
      AND qmel~ernam IN ernam_n
      AND qmel~erdat IN erdat_n
      AND qmel~priok IN priok_n
      AND qmel~qmnam IN qmnam_n           " Autor da Nota
      AND qmel~arbpl IN arbpl_n
      AND qmel~arbplwerk IN vawrk
      AND qmih~iwerk IN iwerk_n
      AND qmih~ingrp IN ingpr_n
      AND qmih~equnr IN equnr_n
  AND iloa~eqfnr IN eqfnr_n.
*  >> 7000038155: TICKETGD-1486 roberto inicio
*      %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
*  >> 7000038155: TICKETGD-1486 roberto fim
  CONSTANTS cc_hints_2 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.

  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*  " ..........................................................................
*  " Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)
*  " ..........................................................................
*  DATA: it_qmfe   TYPE TABLE OF qmfe.
*  DATA: it_qmur   TYPE TABLE OF qmur.
*  DATA: wa_qmur   TYPE qmur.
*  DATA: wa_qmfe   TYPE qmfe.
*  IF rb_dem = 'X' AND dy_dnt = 'X'.
*    " Se há dados de Nota para o relatório 'Demandas:NOTAS sem Medida e sem Ordem'
*    " remove as Notas com Ordem (lcol_note-aufnr) e as Notas com Medida (QMSM-QMNUM)
*    IF lcol_note[] IS NOT INITIAL.
*      DELETE lcol_note WHERE aufnr IS NOT INITIAL OR aufnr <> SPACE.
*
*      LOOP AT lcol_note INTO lstr_note.
*        lc_indice = sy-tabix.
*
*        SELECT SINGLE qmnum  "Nota
*          INTO lc_qmnum
*          FROM qmsm WHERE qmnum = lstr_note-qmnum.
*        IF sy-subrc = 0.
*          DELETE lcol_note INDEX lc_indice.
*        ENDIF.
*      ENDLOOP.
*    ENDIF.
*
*    " Se há dados de Nota para o relatório 'Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)' e foi definido 'Exibir dados do item e dados da causa (dy_didc)'
*    " busca-se os dados de Item e Causa e realiza o filtro com os valores de item e causa informados na tela de seleção
*    " IMPORTANTE 1: Como o modelo de dados de Nota temos 1 Nota x 0,n Itens e 1 Item x 0,n Causas, não entendo se o comportamento do comando lcol_note[] = lcol_note_aux[] funciona corretamente.
*    " IMPORTANTE 2: Devido ao modelo de dados a opção 'Exibir dados do item e dados da causa (dy_didc)' definida gera um relatório com nr de linhas maior
*    "               o que sugere uma REFATORAÇÃO FUTURA PARA TORNAR O RELATÓRIO MENOS COMPLEXO E MAIS INTUITIVO que torne esta opção um outro tipo de relatório
*    IF lcol_note[] IS NOT INITIAL AND dy_didc = 'X'.
*      " Busca dados dos Itens de cada Nota em lcol_Note
*      CLEAR: it_qmfe[].
*      SELECT qmnum fenum fetxt fegrp fecod otgrp oteil FROM qmfe
*        INTO CORRESPONDING FIELDS OF TABLE it_qmfe
*         FOR ALL ENTRIES IN lcol_note
*       WHERE qmnum = lcol_note-qmnum
*         AND kzloesch = ' '.
*      IF sy-subrc = 0.
*        SORT it_qmfe BY qmnum fenum.
*      ENDIF.
*
*      " Busca dados das Causas de cada Nota em lcol_Note
*      CLEAR: it_qmur[].
*      SELECT qmnum fenum urnum urtxt urgrp urcod FROM qmur
*        INTO CORRESPONDING FIELDS OF TABLE it_qmur
*         FOR ALL ENTRIES IN lcol_note
*       WHERE qmnum = lcol_note-qmnum
*         AND kzloesch = ' '.
*      IF sy-subrc = 0.
*        SORT it_qmur BY qmnum fenum urnum.
*      ENDIF.
*
*      " Percorre cada Nota preenchendo os dados de Itens (1 Nota x 0,n Itens) e os dados de Causas (1 Item x 0,n Causas) na ITable auxiliar lcol_note_aux
*      CLEAR: lcol_note_aux[].
*      LOOP AT lcol_note INTO lstr_note.
*        CLEAR: wa_qmfe.
*        LOOP AT it_qmfe INTO wa_qmfe WHERE qmnum = lstr_note-qmnum.
*
*          lstr_note-fenum = wa_qmfe-fenum. "Nº item no registro do item
*          lstr_note-fetxt = wa_qmfe-fetxt. "Texto do item
*          lstr_note-fegrp = wa_qmfe-fegrp. "Problema
*          lstr_note-fecod = wa_qmfe-fecod. "Código do dano
*          lstr_note-otgrp = wa_qmfe-otgrp. "Partes de objetos
*          lstr_note-oteil = wa_qmfe-oteil. "Parte do objeto
*
*          CLEAR: wa_qmur.
*          LOOP AT it_qmur INTO wa_qmur WHERE qmnum = lstr_note-qmnum
*                                         AND fenum = lstr_note-fenum.
*            lstr_note-urnum = wa_qmur-urnum. "Numero de causa atual
*            lstr_note-urtxt = wa_qmur-urtxt. "Texto da causa
*            lstr_note-urgrp = wa_qmur-urgrp. "Causa
*            lstr_note-urcod = wa_qmur-urcod. "Código da causa
*            APPEND lstr_note TO lcol_note_aux.
*          ENDLOOP.
*        ENDLOOP.
*      ENDLOOP.
*
*      " Atribui a ITable auxiliar a ITable principal
*      " IMPORTANTE: Comportamento deste comando pode gerar dados indesejados
*      lcol_note[] = lcol_note_aux[].
*
*      LOOP AT lcol_note INTO lstr_note.
*        PERFORM busca_texto_item_causa USING lstr_note
*                                    CHANGING lstr_note-txtcdfe
*                                             lstr_note-txtcdot
*                                             lstr_note-txtcdur.
*        MODIFY lcol_note FROM lstr_note.
*      ENDLOOP.
*
*      "Texto do item
*      IF fetxt_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT fetxt IN fetxt_n.
*      ENDIF.
*      "Código do dano
*      IF fecod_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT fecod IN fecod_n.
*      ENDIF.
*      "Problema
*      IF fegrp_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT fegrp IN fegrp_n.
*      ENDIF.
*      "Partes de objetos
*      IF otgrp_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT otgrp IN otgrp_n.
*      ENDIF.
*      "Parte do objeto
*      IF oteil_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT oteil IN oteil_n.
*      ENDIF.
*      "Texto da causa
*      IF urtxt_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT urtxt IN urtxt_n.
*      ENDIF.
*      "Causa
*      IF urgrp_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT urtxt IN urgrp_n.
*      ENDIF.
*      "Código da causa
*      IF urcod_n[] IS NOT INITIAL.
*        DELETE lcol_note WHERE NOT urcod IN urcod_n.
*      ENDIF.
*    ENDIF.
*  ENDIF.
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

  " Se não há dados de Nota, retorna
  IF lcol_note[] IS INITIAL.
*    message w641(ysf).
*    return.
    EXIT.
  ENDIF.

  "----------------------------------------------------------------------------------------
  " Busca Gerência Solicitante das Notas
  "----------------------------------------------------------------------------------------
  LOOP AT lcol_note INTO lstr_note.
    lc_indice = sy-tabix.

*   Busca o código do parceiro para recuperar a Gerência Solicitante.
    SELECT SINGLE parnr FROM ihpa INTO lstr_note-parnr "#EC CI_NOORDER or "#EC WARNOK
     WHERE objnr = lstr_note-objnr
    AND parvw = yspm_constants_if=>e_partner-cc_parzg.

    IF sy-subrc = 0.
*     Função para recuperar o nome do parceiro(Gerência Solicitante).
      CALL FUNCTION 'PM_PARTNER_READ'
        EXPORTING
          parvw          = yspm_constants_if=>e_partner-cc_parzg
          parnr          = lstr_note-parnr
        IMPORTING
          diadr_wa       = lwa_diadr
        EXCEPTIONS
          no_valid_parnr = 1
          OTHERS         = 2.

      IF sy-subrc IS INITIAL.
        lstr_note-parvw = yspm_constants_if=>e_partner-cc_parzg.
        lstr_note-name_list = lwa_diadr-name_list.
        MODIFY lcol_note FROM lstr_note INDEX lc_indice.
      ENDIF.
    ENDIF.

    IF lstr_note-arbpl IS NOT INITIAL.
      CALL FUNCTION 'CR_WORKSTATION_READ' ##FM_SUBRC_OK
        EXPORTING
          id        = CONV rcr01-arbid( lstr_note-arbpl )
          msgty     = 'S'
        IMPORTING
          arbpl     = ls_ugewrk_aux
          ktext     = lstr_note-pltxt1
          werks     = ls_uwerk_aux        " NÃO UTILIZADO
        EXCEPTIONS
          not_found = 1.
    ENDIF.

    IF lstr_note-pltxt1 IS NOT INITIAL.
      lstr_note-vaplz = ls_ugewrk_aux.
      MODIFY lcol_note FROM lstr_note INDEX lc_indice.
    ENDIF.
  ENDLOOP.

  "----------------------------------------------------------------------------------------
  " Seleção de Notas compatíveis com os filtros indiretos e inclusão na OUTPUT ITable
  "----------------------------------------------------------------------------------------
  DATA: lcol_notestatus    TYPE TABLE OF jstat,
        lstr_notestatus    LIKE LINE OF lcol_notestatus,
        lc_notestatus_curr TYPE jstat-stat.

  RANGES: lr_note_objnr    FOR aufk-objnr.       " Performance para SELECTs
  "..........................................................................
  " Percorre cada Nota selecionando as compatíveis com os filtro indiretos
  "..........................................................................
  CLEAR:   gcol_noteout.
  REFRESH: gcol_noteout.

  DATA: lc_hora  LIKE rihqmel_list-eauszt.

  LOOP AT lcol_note INTO lstr_note.

    CALL FUNCTION 'CONVERSION_EXIT_ABPSP_OUTPUT'
      EXPORTING
        input  = lstr_note-proid
      IMPORTING
        output = lstr_note-posid.

    CLEAR: lc_hora.
    lc_hora = lstr_note-auszt / 3600.
    lstr_note-auszt = lc_hora.

    "..........................................................................
    " Verifica se a Nota é compatível com os Status informados no filtro
    "..........................................................................
    " Busca os Status de Sistema e Status de Usuário ATIVOS da Nota
    CLEAR:   lcol_notestatus.
    REFRESH: lcol_notestatus.
    CALL FUNCTION 'STATUS_READ'
      EXPORTING
        objnr            = lstr_note-objnr
        only_active      = 'X'
      TABLES
        status           = lcol_notestatus
      EXCEPTIONS
        object_not_found = 01.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    " Busca o Status de Sistema ATIVO da Nota (lc_NoteStatus_Curr) compatível com os Status informados no filtro (lr_Note_Status)
    CLEAR lc_notestatus_curr.
    LOOP AT lcol_notestatus INTO lstr_notestatus.
      IF lstr_notestatus-stat IN lr_note_status.
        lc_notestatus_curr = lstr_notestatus-stat.
        EXIT.
      ENDIF.
    ENDLOOP.

    " Se não foi encontrado Status de Sistema ATIVO da Nota,
    " a Nota não é compatível com os Status informados no filtro (ignora-a)
    IF lc_notestatus_curr IS INITIAL.
      CONTINUE.
    ENDIF.

    "..........................................................................
    " Busca e seta os textos de Status de Sistema e Status de Usuário da Nota
    "..........................................................................
    CALL FUNCTION 'STATUS_TEXT_EDIT'
      EXPORTING
        flg_user_stat    = 'X'
        objnr            = lstr_note-objnr
        spras            = sy-langu
        bypass_buffer    = 'X'
      IMPORTING
        line             = lc_notif_status_line
        user_line        = lc_notif_userstat_line
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.

    IF sy-subrc EQ 0.
      CLEAR: lstr_status_syst_user_aux.
      CONCATENATE lc_notif_status_line lc_notif_userstat_line INTO lstr_status_syst_user_aux SEPARATED BY space.

      " Filtro 'Status Inclusivo - Notas'
      IF stai1_n IS NOT INITIAL.
        wc_exit = abap_true.
        LOOP AT stai1_n.
          TRANSLATE stai1_n-low TO UPPER CASE.
          CONCATENATE '*' stai1_n-low '*' INTO lstr_status_aux.
          " Se a Nota corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Inclusivo, MANTÉM a Ordem (wc_exit = ABAP_FALSE)
          IF lstr_status_syst_user_aux CP lstr_status_aux.
            wc_exit = abap_false.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF wc_exit = abap_true.
          CONTINUE.
        ENDIF.
      ENDIF.

      " Filtro 'Status Exclusivo - Notas'
      IF stae1_n IS NOT INITIAL.
        wc_exit = abap_false.
        LOOP AT stae1_n.
          TRANSLATE stae1_n-low TO UPPER CASE.
          CONCATENATE '*' stae1_n-low '*' INTO lstr_status_aux.
          " Se a Ordem corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Exclusivo, IGNORA/REMOVE a Ordem (wc_exit = ABAP_TRUE)
          IF lstr_status_syst_user_aux CP lstr_status_aux.
            wc_exit = abap_true.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF wc_exit = abap_true.
          CONTINUE.
        ENDIF.

      ENDIF.

      lstr_note-sttxt = lc_notif_status_line.
      lstr_note-ustxt = lc_notif_userstat_line.
      CLEAR: lc_notif_status_line, lc_notif_userstat_line, lstr_status_aux.

    ELSE.
      CLEAR: lstr_note-sttxt, lstr_note-ustxt.
      CONTINUE.
    ENDIF.

    CLEAR: lstr_note-ktext2.
    IF NOT  lstr_note-stort IS INITIAL.
      SELECT SINGLE ktext                "#EC CI_NOORDER or "#EC WARNOK
      INTO  lstr_note-ktext2
      FROM  t499s
      WHERE  stand = lstr_note-stort.    "#EC CI_NOORDER or "#EC WARNOK
    ENDIF.

    " Inclusão da Nota selecionada na OUTPUT ITable
    APPEND lstr_note TO gcol_noteout.

    " Inclusão da Nota selecionada no RANGE de Notas selecionadas
    lr_note_objnr-low    = lstr_note-objnr.
    lr_note_objnr-sign   = 'I'.
    lr_note_objnr-option = 'EQ'.

    APPEND lr_note_objnr.

  ENDLOOP.

  "Responsável
  IF NOT parnr_n IS INITIAL."Responsável
    DELETE gcol_noteout WHERE NOT vaplz IN parnr_n.
  ENDIF.

  " Se não existem dados na OUTPUT ITable, retorna
  IF gcol_noteout[] IS INITIAL.
    MESSAGE w641(ysf).
*    return.
  ENDIF.

  " -----------------------------------------------------------------
  " Seleção de Histórico de Status das Notas selecionadas
  " -----------------------------------------------------------------
  DATA: lcol_jcds TYPE HASHED TABLE OF jcds WITH UNIQUE KEY primary_key COMPONENTS objnr stat chgnp chgnr,
        lstr_jcds LIKE LINE OF lcol_jcds.

* Início: PE2K928614-XU86-20.06.2012-S-5000050630-NTI239012-InclVinc. EL PeP ZS ZF Med ZR,
  SORT lr_note_objnr BY  low.

  DELETE ADJACENT DUPLICATES FROM lr_note_objnr COMPARING low.

  IF NOT lr_note_objnr[] IS INITIAL.
    SELECT * APPENDING TABLE lcol_jcds
      FROM jcds
       FOR ALL ENTRIES IN lr_note_objnr
    WHERE jcds~objnr EQ lr_note_objnr-low.
*  >> 7000038155: TICKETGD-1486 roberto inicio
*    %_HINTS ORACLE '&MAX_BLOCKING_FACTOR 250&'
*            ORACLE '&MAX_IN_BLOCKING_FACTOR 250&'.
*  >> 7000038155: TICKETGD-1486 roberto fim
    CONSTANTS cc_hints_1 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.
    IF sy-subrc = 0.                                        "7000059731
      SORT lcol_jcds BY objnr stat.                         "7000059731
    ENDIF.                                                  "7000059731
  ENDIF.

  "----------------------------------------------------------------------------------------------
  " Preenchimento de dados complementares de cada Nota selecionada e alteração na OUTPUT ITable
  "----------------------------------------------------------------------------------------------
  DATA: lstr_noteout LIKE LINE OF gcol_noteout,
        li_tabixout  TYPE syst-tabix.

  ".............................................................................
  " Percorre cada Nota selecionada preenchendo os dados de Histórico de Status
  ".............................................................................
  LOOP AT gcol_noteout INTO lstr_noteout.
    " Seta OUTPUT ITable Tabix
    li_tabixout = sy-tabix.

    " Busca dados de Histórico de Status para Nota ABERTA (PENDENTE)
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_noteout-objnr
                                                                              stat  = c_note_status-outstanding
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_noteout-outstanding_uname     = lstr_jcds-usnam.   " Criado por [Autor do Status MSPN da Nota]
      lstr_noteout-outstanding_date      = lstr_jcds-udate.   " Data de criação [Data do Status MSPN da Nota]
      lstr_noteout-outstanding_time      = lstr_jcds-utime.   " Hora de criação [Hora do Status MSPN da Nota]

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds USING KEY primary_key
        WHERE objnr = lstr_noteout-objnr
          AND stat  = c_note_status-outstanding
          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_noteout-outstanding_uname     = lstr_jcds-usnam.   " Criado por [Autor do Status MSPN da Nota]
        lstr_noteout-outstanding_date      = lstr_jcds-udate.   " Data de criação [Data do Status MSPN da Nota]
        lstr_noteout-outstanding_time      = lstr_jcds-utime.   " Hora de criação [Hora do Status MSPN da Nota]
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Nota ADIADA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_noteout-objnr
                                                                              stat  = c_note_status-postponed
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_noteout-postponed_uname    = lstr_jcds-usnam.      " Adiado por [Autor do Status MSDI da Nota]
      lstr_noteout-postponed_date     = lstr_jcds-udate.      " Data de adiamento [Data do Status MSDI da Nota]
      lstr_noteout-postponed_time     = lstr_jcds-utime.      " Hora de adiamento [Hora do Status MSDI da Nota]

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds USING KEY primary_key
              WHERE objnr = lstr_noteout-objnr
                AND stat  = c_note_status-postponed
                AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
                      chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_noteout-postponed_uname    = lstr_jcds-usnam.      " Adiado por [Autor do Status MSDI da Nota]
        lstr_noteout-postponed_date     = lstr_jcds-udate.      " Data de adiamento [Data do Status MSDI da Nota]
        lstr_noteout-postponed_time     = lstr_jcds-utime.      " Hora de adiamento [Hora do Status MSDI da Nota]

        EXIT.
      ENDLOOP.

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM
    ENDIF.

    " Busca dados de Histórico de Status para Nota EM PROCESSAMENTO
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_noteout-objnr
                                                                              stat  = c_note_status-inprocess
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_noteout-inprocess_uname   = lstr_jcds-usnam.       " Aprovado por [Autor do Status MSPR da Nota]
      lstr_noteout-inprocess_date    = lstr_jcds-udate.       " Data de aprovação [Data do Status MSPR da Nota]
      lstr_noteout-inprocess_time    = lstr_jcds-utime.       " Hora de aprovação [Hora do Status MSPR da Nota]

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds USING KEY primary_key
              WHERE objnr = lstr_noteout-objnr
                AND stat  = c_note_status-inprocess
          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_noteout-inprocess_uname   = lstr_jcds-usnam.       " Aprovado por [Autor do Status MSPR da Nota]
        lstr_noteout-inprocess_date    = lstr_jcds-udate.       " Data de aprovação [Data do Status MSPR da Nota]
        lstr_noteout-inprocess_time    = lstr_jcds-utime.       " Hora de aprovação [Hora do Status MSPR da Nota]
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Nota COM ORDEM ATRIBUÍDA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_noteout-objnr
                                                                              stat  = c_note_status-oassigned
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_noteout-oassigned_uname   = lstr_jcds-usnam.       " Ordem atribuída por [Autor do Status ORDA da Nota]
      lstr_noteout-oassigned_date    = lstr_jcds-udate.       " Data de atribuição [Data do Status ORDA da Nota]
      lstr_noteout-oassigned_time    = lstr_jcds-utime.       " Hora de atribuição [Hora do Status ORDA da Nota]

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds USING KEY primary_key
              WHERE objnr = lstr_noteout-objnr
                AND stat  = c_note_status-oassigned
          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_noteout-oassigned_uname   = lstr_jcds-usnam.       " Ordem atribuída por [Autor do Status ORDA da Nota]
        lstr_noteout-oassigned_date    = lstr_jcds-udate.       " Data de atribuição [Data do Status ORDA da Nota]
        lstr_noteout-oassigned_time    = lstr_jcds-utime.       " Hora de atribuição [Hora do Status ORDA da Nota]
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    " Busca dados de Histórico de Status para Nota ENCERRADA
    " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
    "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
    " IMPORTANTE: Foi realizado uma correção emergencial e paliativo APENAS para garantir que seja apresentada a 1a ocorrência dos Status recorrentes (MSEN)
    "             pois apresentava uma determinada data de ocorrência do Status diferente para uma Nota dependendo da quantidade de notas apresentadas.
    "             Entretanto, deve ser definido se um Status recorrente (como MSEN) deve ser considerado para o processo
    "             a sua 1a ocorrência ou a sua última ocorrência, bem como se um Status recorrente deve ser considerado se atualmente não está ativo
    "             (por ex.: Nota MSPR no momento que foi colocado novamente em processamento a partir de MSEN, já tem uma ocorrência no Status)
    READ TABLE lcol_jcds INTO lstr_jcds WITH TABLE KEY primary_key COMPONENTS objnr = lstr_noteout-objnr
                                                                              stat  = c_note_status-completed
                                                                              chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
                                                                              chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
    "   AND inact <> ' '.
    IF sy-subrc = 0.
      lstr_noteout-completed_uname  = lstr_jcds-usnam.        " Encerrado por [Autor do Status MSEN da Nota]
      lstr_noteout-completed_date   = lstr_jcds-udate.        " Data de encerramento [Data do Status MSEN da Nota]
      lstr_noteout-completed_time   = lstr_jcds-utime.        " Hora de encerramento [Hora do Status MSEN da Nota]

* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - INÍCIO
* Chamado INC0356065
* Request:S4DK963505
* Motivo: As colunas Referentes a Usuário/Data/Hora dos Status não estão sendo carregadas no Relatório
* Devido a Aplicação da Nota KBA 3317045, o campo jcds-chgnp está como 000 e não 001. Por isso a Ordem não selecionada no READ acima.
    ELSE.
      LOOP AT lcol_jcds INTO lstr_jcds USING KEY primary_key
              WHERE objnr = lstr_noteout-objnr
                AND stat  = c_note_status-completed
          AND ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
                chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
        lstr_noteout-completed_uname  = lstr_jcds-usnam.        " Encerrado por [Autor do Status MSEN da Nota]
        lstr_noteout-completed_date   = lstr_jcds-udate.        " Data de encerramento [Data do Status MSEN da Nota]
        lstr_noteout-completed_time   = lstr_jcds-utime.        " Hora de encerramento [Hora do Status MSEN da Nota]
        EXIT.
      ENDLOOP.
* 26/06/2023 - Alexandre XZDW - Alexsandro(PM) - FIM

    ENDIF.

    MODIFY gcol_noteout INDEX li_tabixout  FROM lstr_noteout.

  ENDLOOP.

ENDFORM.                    "f_SSCRGetData_Note
*&---------------------------------------------------------------------*
*&      Form  F_SSCRGETDATA_MED
*&---------------------------------------------------------------------*
*       Seleção dos dados de medida
*----------------------------------------------------------------------*
FORM f_sscrgetdata_med .
  DATA: lc_medida_status_line     TYPE bsvx-sttxt,
        lc_medida_userstat_line   TYPE bsvx-sttxt,
        lstr_status_aux           TYPE string,
        lstr_status_syst_user_aux TYPE string.
  DATA: lc_notif_status_line   TYPE bsvx-sttxt,
        lc_notif_userstat_line TYPE bsvx-sttxt.
  DATA: l_date LIKE sy-datum.                               "7000059731
  RANGES: lr_med_qmdab      FOR qmel-qmdab. " Data de encerramento da nota

  "..........................................................................................
  "   Construção de RANGE de Datas do período informado no filtro (Data de Referência da Nota)
  "..........................................................................................
  " Na iw28 a Data de Referência é a sempre a Data da Nota (coluna qmel-qmdat) definida sempre na iw22 para qualquer Status (diferentemente da Ordem que tem uma lógica para a Data de Referência)
  RANGES: lr_med_qmdat   FOR qmel-qmdat.   " Range das datas do período do filtro
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Inicio*
*-----------------------------------------------------------------------------------------------*

  " Se uma das datas do período foi informada, seta as variáveis de período de acordo com o filtro informado e insere o intervalo no RANGE
  " Senão, se as datas não foram informadas, nada faz. O RANGE ficará vazio e o período não será considerado como filtro no SQL
  IF NOT datuv_m IS INITIAL OR NOT datub_m IS INITIAL.

    " Se somente a data final foi informada, seta a data inicial com a data-base do SAP
    IF datuv_m IS INITIAL AND NOT datub_m IS INITIAL.
      datuv_m = '19000101'.

*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datub_m                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '-'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datuv_m = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731

    " Se somente a data inicial foi informada, seta a data final com a data-teto do SAP
    IF NOT datuv_m IS INITIAL AND datub_m IS INITIAL.
      datub_m = '99991231'.
*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datuv_m                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '+'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datub_m = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731

    " Insere o intervalo (BETWEEN = BT) da data inicial e data final
    lr_med_qmdat-low    = datuv_m.
    lr_med_qmdat-high   = datub_m.
    lr_med_qmdat-sign   = 'I'.
    lr_med_qmdat-option = 'BT'.
    APPEND lr_med_qmdat.
  ENDIF.

  "..........................................................................................
  "   Construção de RANGE por Tipo de Nota
  "..........................................................................................
  " POR PERFORMANCE: Na iw28 o Tipo de Nota mesmo que setado como * no filtro é substituido por um RANGE com todas as Notas de PM (QMTYP = 01) e Notas de Serviço (QMTYP = 03)
  RANGES: lr_med_qmart   FOR qmel-qmart.   " Range de Tipo de Nota

  " Se foi setado * monta um RANGE com todos Tipos de Nota considerados na iw28
  " Senão, o RANGE será o próprio qmart (PARAMETER da SELECTION-SCREEN)
  IF qmart_m-low = '*' AND qmart_m-option = 'CP'.
    " Busca Tipos de Nota (tive que colocar as LOW para preencher corretamente o RANGE)
    SELECT qmart AS low
    FROM tq80
    APPENDING CORRESPONDING FIELDS OF TABLE lr_med_qmart
    WHERE tq80~qmtyp IN ('01' , '03').  " Tx iw28 somente são considerados Notas de PM e Notas de Serviço (qmtyp=01, 03)

    " Corrige os parâmetros do RANGE de Tipos de Nota
    LOOP AT lr_med_qmart.
      lr_med_qmart-sign   = 'I'.
      lr_med_qmart-option = 'EQ'.
      MODIFY lr_med_qmart.
    ENDLOOP.
  ELSE.
    lr_med_qmart[] = qmart_m[].
  ENDIF.


  " ---------------------------------------------------------------------------------------------------------------------
  " Busca códigos dos Status de Usuário de Medida de acordo com o Esquema de Status de Medida default corrente
  " ---------------------------------------------------------------------------------------------------------------------
  DATA: lc_medida_ustatuscode_emelabor TYPE j_estat,
        lc_medida_ustatuscode_ctec     TYPE j_estat,
        lc_medida_ustatuscode_ph       TYPE j_estat,
        lc_medida_ustatuscode_recb     TYPE j_estat,
        lstr_tq80                      TYPE tq80.
  " Busca o Esquema de Status (tq80-smstsma) definido para a Medida da Nota de Recomendação (YSPM_CONSTANTS_IF=>E_NOTIF_TYPE-CC_RECOMENDACAO)
  CALL FUNCTION 'RETURN_TQ80_STRUCT'
    EXPORTING
      iv_qmart = yspm_constants_if=>e_notif_type-cc_recomendacao
    IMPORTING
      es_tq80  = lstr_tq80.

  " Busca o código do Status de Usuário EM ELABORACAO no Esquema de Status de Medida default corrente
  CALL FUNCTION 'STATUS_TEXT_CONVERSION'
    EXPORTING
      language           = sy-langu
      mode               = 'E'
      stsma              = lstr_tq80-smstsma
      txt04              = yspm_constants_if=>e_medida_userstatus_txt04-cc_em_elaboracao
    IMPORTING
      status_number      = lc_medida_ustatuscode_emelabor
    EXCEPTIONS
      insufficient_input = 1
      not_found          = 2
      object_not_found   = 3
      wrong_mode         = 4
      OTHERS             = 5.
  " Se não encontrou o código do Status de Usuário limpa sua respectiva variável
  IF sy-subrc <> 0.
    CLEAR lc_medida_ustatuscode_emelabor.
  ENDIF.

  " Busca o código do Status de Usuário CONCLUÍDA PELO TÉCNICO no Esquema de Status de Medida default corrente
  CALL FUNCTION 'STATUS_TEXT_CONVERSION'
    EXPORTING
      language           = sy-langu
      mode               = 'E'
      stsma              = lstr_tq80-smstsma
      txt04              = yspm_constants_if=>e_medida_userstatus_txt04-cc_concluida_tec
    IMPORTING
      status_number      = lc_medida_ustatuscode_ctec
    EXCEPTIONS
      insufficient_input = 1
      not_found          = 2
      object_not_found   = 3
      wrong_mode         = 4
      OTHERS             = 5.
  " Se não encontrou o código do Status de Usuário limpa sua respectiva variável
  IF sy-subrc <> 0.
    CLEAR lc_medida_ustatuscode_ctec.
  ENDIF.

  " Busca o código do Status de Usuário PH no Esquema de Status de Medida default corrente
  CALL FUNCTION 'STATUS_TEXT_CONVERSION'
    EXPORTING
      language           = sy-langu
      mode               = 'E'
      stsma              = lstr_tq80-smstsma
      txt04              = yspm_constants_if=>e_medida_userstatus_txt04-cc_prof_habilitado
    IMPORTING
      status_number      = lc_medida_ustatuscode_ph
    EXCEPTIONS
      insufficient_input = 1
      not_found          = 2
      object_not_found   = 3
      wrong_mode         = 4
      OTHERS             = 5.
  " Se não encontrou o código do Status de Usuário limpa sua respectiva variável
  IF sy-subrc <> 0.
    CLEAR lc_medida_ustatuscode_ph.
  ENDIF.

  " Busca o código do Status de Usuário RECEBIDA PELO RESPONSÁVEL no Esquema de Status de Medida default corrente
  CALL FUNCTION 'STATUS_TEXT_CONVERSION'
    EXPORTING
      language           = sy-langu
      mode               = 'E'
      stsma              = lstr_tq80-smstsma
      txt04              = yspm_constants_if=>e_medida_userstatus_txt04-cc_recebida_resp
    IMPORTING
      status_number      = lc_medida_ustatuscode_recb
    EXCEPTIONS
      insufficient_input = 1
      not_found          = 2
      object_not_found   = 3
      wrong_mode         = 4
      OTHERS             = 5.
  " Se não encontrou o código do Status de Usuário limpa sua respectiva variável
  IF sy-subrc <> 0.
    CLEAR lc_medida_ustatuscode_recb.
  ENDIF.


  " ----------------------------------------------------------------------------------------
  " Seleção de Notas/Medidas compatíveis com os dados informados no filtro
  " ----------------------------------------------------------------------------------------
  DATA: lcol_med TYPE TABLE OF ty_med.
  DATA: ls_ugewrk_aux LIKE riwo00-gewrk,
        ls_uwerk_aux  LIKE riwo00-swerk.
  CLEAR: gcol_medout[].

**  " IGOR CHECK BIG TEST +++ INI +++ (RUN WITH MY USER Y1RA) - COMMENT/UNCOMMENT ALL THIS CODE BLOCK
**  BREAK ABAPY1RA. BREAK Y1RA.    " (ONLY FOR DEBUG TESTS)
*  IF SY-UNAME = 'Y1RA'. " OR sy-batch = abap_true OR sy-ucomm = 'SJOB'.     " OR SY-UNAME = 'ABAPY1RA'
*  SELECT
*    qmsm~qmnum
*      qmsm~fenum as m_fenum                       " PARTE:  Id Parte [Identificador interno da Parte]                                 1
*      qmsm~qsmnum as m_qsmnum                     " MEDIDA: No Medida [Número da Medida]                                              1
*      qmsm~manum  as m_manum                      "         Id Medida [Identificador interno da Medida]                               12
*      qmsm~mnkat  as m_mnkat                      " Tipo catálogo-Medida [idem]                                                       2
*      qmsm~mngrp  as m_mngrp                      " Grupo-Medida [Grupo de códigos da Medida]                                         CAMPSPAR
*      " m_txt_mngrp TYPE qpgt-kurztext            " Texto do Grupo-Medida [Texto do Grupo de códigos da Medida]                       Execução Campanha - sem PAR
*      qmsm~mncod  as m_mncod                      " Medida [Código da Medida]                                                         A
*      " m_txt_mncod TYPE qpct-kurztext            " Texto da Medida [Texto do código da Medida]                                       Alto
*      qmsm~matxt  as m_matxt                      " Texto breve da Medida [idem]                                                      Texto breve RTI 2.1
*      qmsm~objnr  as m_objnr
*      qmsm~parvw  as m_parvw                      " Função do responsável pela medida
*      qmsm~parnr  as m_parnr                      " Responsável pela medida (nº parceiro)
*      qmsm~erdat qmsm~ernam qmsm~aedat qmsm~aenam " Data criação/modificação e criador/modificador
*      qmsm~yyaufnr                                " Ordem atribuída à Medida
*      qmsm~yystort                                " Localização da Medida/Nota [ou da Medida ou da Nota da Medida] [SQL para busca da Localização da Medida]
*      " yystort_ktext TYPE t499s-ktext            " Descrição da Localização da Medida/Nota [ou da Medida ou da Nota da Medida]
*      qmsm~yyposid qmsm~yyaufnr_net
*      qmsm~indtx
*      qmsm~pster                              " Data plan. inicio
*      qmsm~peter                              " Fim planejado
*                  FROM qmsm
*  APPENDING CORRESPONDING FIELDS OF TABLE lcol_med
**   WHERE qmsm~qmnum <= '000200390000'    " test4 - 520.815 linhas (IGOR CHECK TEST BIG VOLUME PED 220 na se16 colocar somente o 2o campo do options, senão traz nr de linhas <> )
**   WHERE qmsm~qmnum <= '000200170000'    " test1 - 179.616 linhas (IGOR CHECK TEST BIG VOLUME PED 220)
*   WHERE qmsm~qmnum <=  '000200037000'   " test2 -  39.513 linhas (IGOR CHECK TEST BIG VOLUME PED 220)
**   WHERE qmsm~qmnum <= '000200059000'    " test3 -  61.917 linhas (IGOR CHECK TEST BIG VOLUME PED 220)
*              %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
*
*   DATA lstr_med_aux_del LIKE LINE OF lcol_med.
*  lstr_med_aux_del-objnr = 'QM000000014654'.           " Igor check: mandatory for getting notification status  commenting return command below
*  MODIFY lcol_med FROM lstr_med_aux_del TRANSPORTING objnr where OBJNR IS INITIAL.
*  SORT lcol_med BY qmnum m_qsmnum m_manum a_manum.                              " REMOVE THIS
*  DELETE ADJACENT DUPLICATES FROM lcol_med COMPARING qmnum m_qsmnum m_manum.    " REMOVE THIS
*  "gcol_medout = lcol_med.       RETURN.   " REMOVE THIS ==> IGOR CHECK TEST: ***** SE QUISER RODAR O LOOP COM JCDS COMENTAR ESTAS 2 LINHAS: A ATRIBUIÇÃO lcol_med E RETURN +++++++++
*
*  " IGOR CHECK BIG TEST +++ MIDDLE +++ (RUN WITH MY USER Y1RA) - COMMENT/UNCOMMENT ONLY THE LINE OF THIS ELSE.
*  ELSE.
**  " IGOR CHECK BIG TEST +++END+++ (RUN ONLY WITH USER Y1RA) - REMOVE ONLY THE LINE OF THIS ENDIF.  " *** ATTENTION *** THIS 'ENDIF' MUST BE AFTER THE ORIGINAL SQL
**  ENDIF.

  " ..................................................................................................................................
  " MEDIDAS (SQL PRINCIPAL)
  " ..................................................................................................................................
  " ### IMPORTANTE ###
  " FAVOR NÃO REFATORAR SEM ALINHAMENTO COM A ÁREA FUNCIONAL DO MÓDULO SAP PM
  " Devido a criticidade da transação é MANDATÓRIO conhecimento do respectivo modelo de dados SAP PM
  " para implementar alterações (visando performance ou não) sem reflexos colaterais indesejados para os usuários finais
  " ..................................................................................................................................
  " INFORMAÇÕES RELEVANTES:
  " - Plano não se aplica a Nota ZR no processo de Inspeção PETROBRAS  - Tabela MPLA não utilizada
  " - Informação de texto longo somente da Medida
  SELECT
      qmel~mandt
      qmel~qmart              " Tipo de nota
      qmel~qmnum
      qmel~aufnr
      qmel~qmtxt              " Texto breve da Nota
      qmel~qmnam              " Autor da Nota
      qmel~qmdat              " Data da nota
      qmel~objnr
      qmel~arbpl              " Centro de trabalho responsável da Nota
      " DADOS DA NOTA NÃO RELEVANTES NO RELATÓRIO DE MEDIDAS
      "qmel~priok              " Prioridade
      "qmel~phase
      "qmel~artpr              " Tipo de prioridade
      "qmel~kunum              " Nº conta do cliente
      "qmel~kzmla              " Código: Segmento de texto em idioma principal
      "qmel~adrnr              " Endereços: nº do endereço
      "qmel~erdat              " Data de criação
      "qmel~aedat              " Data da última modificação
      "qmel~aenam              " Nome do responsável pela modificação do objeto
      "qmel~indtx AS indtx_qmel" Indicador texto longo da Nota
      qmel~rbnr               " Perfil de catálogo
      qmel~yyimpacto_falha    " Id Impacto Falha (Nota)  [snapshot do Impacto Falha do Local de Instalação (iflot~yyimpacto_falha) no momento da criação da Nota]
      ysimpfalha~descricao    " Descritor do Impacto da Falha (Nota)
      qmih~ingrp              " Grupo de planejamento para serviços cliente e manutenção
      qmih~iwerk              " Centro planejamento
      qmih~equnr              " Equipamento
      eqkt~eqktx              " Denominação do objeto técnico (Equipamento)
      qmih~bautl              " Conjunto
      qmih~ausvn              " Início avaria
      qmih~ausbs              " Fim da avaria
      qmih~btpln              " Local instal.afetado
      qmih~bequi              " Equipamento afetado
*      qmih~YYAREAPLAN         " Área degradada (m²) - Abapf1pp - amss - 21/08/2025
*      qmih~YYAREAEXEC         " Área pintada (m²)   - Abapf1pp - amss - 21/08/2025
*      qmih~YYAREATIPO         " Tipo de área        - Abapf1pp - amss - 21/08/2025
      "qmih~msaus              " Parada                                       NOTA ZER NÃO TEM PARADA (INFORMAÇÃO NÃO PERTINENTE A NOTA ZR DE MEDIDA)
      "qmih~warpl              " Plano de manutenção (se a Nota tiver plano)  NOTA ZR NÃO TEM PLANO NO PROCESSO INSPEÇÃO PETROBRAS
      "qmih~auszt              " Duração da parada                            NOTA ZR NÃO TEM CONCEITO DE PARADA NO PROCESSO INSPEÇÃO PETROBRAS
      "qmih~maueh              " Unidade de tempo para a duração da parada    NOTA ZR NÃO TEM CONCEITO DE PARADA NO PROCESSO INSPEÇÃO PETROBRAS
      iloa~tplnr              " Local de Instalação
      iloa~kokrs              " Área de contabilidade de custos
      iloa~kostl              " Centro de custo (Nota) [da Nota da Medida]
      iloa~eqfnr              " Campo de seleção
      iloa~beber              " Área operacional
      iloa~swerk              " Centro de localização (Nota) [snapshot do Centro de Localização do Local de Instalação (iflot~yycentro ou ILOA-SWERK do próprio Local) no momento da criação da Nota]
      iloa~stort              " Localização da Nota da Medida [NÃO SERÁ APRESENTADO: SQL para busca da Localização da Nota]
      iloa~beber              " Área Operacional
      iloa~proid              " Elemento PEP Interno
      iloa~abckz              " Código ABC
      iflot~tplkz             " Código da estrutura do loc.instalação
      iflotx~pltxt            " Denominação do loc.instalação
      iflot~yyimpacto_falha AS yyimpacto_falha_local  " Id Impacto Falha (Local)        [vide 'Id Impacto Falha (Nota)']
      iflot~yycentro        AS swerk_local            " Centro de localização (Local)   [vide 'Centro de localização (Nota)']
      qmel~prueflos           " Lote de Controle
      " CATÁLOGOS DA NOTA
      qmel~qmkat AS qmkat                     " PROBFALHA: Tipo catálogo-ProbFalha [idem]                                       X
      qmel~qmgrp AS qmgrp                     " Grupo-ProFalha [Grupo de códigos da ProbFalha]                                  CODFALHA
      " txt_qmgrp TYPE qpgt-kurztext          " Texto do Grupo-ProbFalha [Texto do Grupo de códigos da ProbFalha]               Códigos de Falha
      qmel~qmcod AS qmcod                     " ProbFalha [Código da ProbFalha]                                                 C
      " txt_qmcod TYPE qpct-kurztext          " Texto da ProbFalha [Texto do código da ProbFalha]                               Baixa Probabilidade de Falha

      qmfe~posnr AS m_posnr                   " PARTE: No Parte [Número da Parte]                                               1
      qmfe~fenum AS m_fenum                   "        Id Parte [Identificador interno da Parte]                                1
      qmfe~otkat AS m_otkat                   " Tipo catálogo-Parte [idem]                                                      B
      qmfe~otgrp AS m_otgrp                   " Grupo-Parte [Grupo de códigos da Parte]                                         PMBOMVAC
      " m_txt_otgrp TYPE qpgt-kurztext        " Texto do Grupo-Parte [Texto do Grupo de códigos da Parte]                       Bomba Vácuo
      qmfe~oteil AS m_oteil                   " Parte [Código da Parte]                                                         AAAA
      " m_txt_oteil TYPE qpct-kurztext        " Texto da Parte [Texto do código da Parte]                                       Bomba Vácuo (Completo)
      qmfe~fetxt AS m_fetxt                   " Texto breve da Parte [idem]                                                      Texto breve Parte 1

      qmfe~fekat AS m_fekat                   " DEFEITO: Tipo catálogo-Defeito [idem]                                       9
      qmfe~fegrp AS m_fegrp                   " Grupo-Defeito [Grupo de códigos do Defeito]
      qmfe~indtx AS a_indtx                   " texto descritivo para o objeto - Nota de qualidade - ítens - amss 15/10/2023
      " m_txt_fegrp TYPE qpgt-kurztext        " Texto do Grupo-Defeito [Texto do Grupo de códigos do Defeito]               Pintura
      qmfe~fecod AS m_fecod                   " Defeito [Código do Defeito]                                                 PCAL
      " m_txt_fecod TYPE qpct-kurztext        " Texto do Defeito [Texto do código do Defeito]                               Casca de Laranja

      qmur~qurnum                          " CAUSA: No Causa [Número da Causa]                                 1
      qmur~urnum                           "        Id Causa [Identificador interno da Causa]                  6
      qmur~urkat                           " Tipo catálogo-Causa [idem]                                        Z
      qmur~urgrp                           " Grupo-Causa [Grupo de códigos da Causa]                           FUNDICAO
      " txt_urgrp TYPE qpgt-kurztext       " Texto do Grupo-Causa [Texto do Grupo de códigos da Causa]         Fundido/Forjado/Laminado
      qmur~urcod                           " Causa [Código da Causa]                                           FCAL
      " txt_urcod TYPE qpct-kurztext       " Texto da Causa [Texto do código da Causa]                         Caldeamento Incompleto
      qmur~urtxt                           " Texto breve da Causa [idem]                                       Texto breve Causa Y
      qmur~erdat AS m_erdat                "Data de criação da causa - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59

      qmsm~qsmnum AS m_qsmnum                     " MEDIDA: No Medida [Número da Medida]                                              1
      qmsm~manum  AS m_manum                      "         Id Medida [Identificador interno da Medida]                               12
      qmsm~mnkat  AS m_mnkat                      " Tipo catálogo-Medida [idem]                                                       2
      qmsm~mngrp  AS m_mngrp                      " Grupo-Medida [Grupo de códigos da Medida]                                         CAMPSPAR
      " m_txt_mngrp TYPE qpgt-kurztext            " Texto do Grupo-Medida [Texto do Grupo de códigos da Medida]                       Execução Campanha - sem PAR
      qmsm~mncod  AS m_mncod                      " Medida [Código da Medida]                                                         A
      " m_txt_mncod TYPE qpct-kurztext            " Texto da Medida [Texto do código da Medida]                                       Alto
      qmsm~matxt  AS m_matxt                      " Texto breve da Medida [idem]                                                      Texto breve RTI 2.1
      qmsm~objnr  AS m_objnr
      qmsm~parvw  AS m_parvw                      " Função do responsável pela medida
      qmsm~parnr  AS m_parnr                      " Responsável pela medida (nº parceiro)
      qmsm~erdat qmsm~ernam qmsm~aedat qmsm~aenam " Data criação/modificação e criador/modificador
      qmsm~yyaufnr                                " Ordem atribuída à Medida
      qmsm~yystort                                " Localização da Medida/Nota [ou da Medida ou da Nota da Medida] [SQL para busca da Localização da Medida]
      " yystort_ktext TYPE t499s-ktext            " Descrição da Localização da Medida/Nota [ou da Medida ou da Nota da Medida]
      qmsm~yyposid qmsm~yyaufnr_net
      qmsm~indtx
      qmsm~pster                              " Data plan. inicio
      qmsm~peter                              " Fim planejado
      qmsm~yyareaplan                         " Área degradada (m²) - Abapf1pp - amss - 26/08/2025
      qmsm~yyareaexec                         " Área pintada (m²)   - Abapf1pp - amss - 26/08/2025
      qmsm~yyareatipo                         " Tipo de área        - Abapf1pp - amss - 26/08/2025
      qmma~qmanum AS a_qmanum                 " AÇÃO: No Ação [Número da Ação]                                              1
      qmma~manum  AS a_manum                  "       Id Ação [Identificador interno da Ação]                               7
      qmma~mnkat  AS a_mnkat                  " Tipo catálogo-Ação [idem]                                                   A
      qmma~mngrp  AS a_mngrp                  " Grupo-Ação [Grupo de códigos da Ação]                                       PMGERAL
      " a_txt_mngrp TYPE qpgt-kurztext        " Texto do Grupo-Ação [Texto do Grupo de códigos da Ação]                     Ações Manutenção / Inspeção
      qmma~mncod  AS a_mncod                  " Ação [Código da Ação]                                                       MONI
      " a_txt_mncod TYPE qpct-kurztext        " Texto da Ação [Texto do código da Ação]                                     Monitorar
      qmma~matxt  AS a_matxt                  " Texto breve da Ação [idem]                                                  Texto breve Ação da RTI Z
      qmma~erdat  AS a_erdat                  "Data de criação da ação - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
      qmma~pster  AS a_pster
      qmma~peter  AS a_peter
      qmma~indtx  AS b_indtx                   " Texto descritivo para o objeto  - Nota de qualidade - ações amss 15/10/2023
      qmsm~yyprazorti
                  FROM qmel
            INNER JOIN qmih ON qmih~qmnum = qmel~qmnum
       LEFT OUTER JOIN ysimpfalha  ON ysimpfalha~impacto_falha = qmel~yyimpacto_falha
       LEFT OUTER JOIN eqkt        ON eqkt~equnr = qmih~equnr
                                  AND eqkt~spras = sy-langu
            INNER JOIN iloa        ON iloa~iloan = qmih~iloan
       LEFT OUTER JOIN iflot       ON iflot~tplnr  = iloa~tplnr
       LEFT OUTER JOIN iflotx      ON iflotx~mandt = iloa~mandt
                                  AND iflotx~tplnr = iloa~tplnr
                                  AND iflotx~spras = sy-langu
            INNER JOIN qmfe        ON qmfe~qmnum    = qmel~qmnum     " Nota - ítens (1 nota -> n itens)
                                  AND qmfe~kzloesch = space
       LEFT OUTER JOIN qmur        ON qmur~qmnum    = qmfe~qmnum     " Nota - causas (1 item -> n causas)
                                  AND qmur~fenum    = qmfe~fenum
                                  AND qmur~kzloesch = space
            INNER JOIN qmsm        ON qmsm~qmnum    = qmfe~qmnum     " Nota - medidas (1 item -> n medidas)
                                  AND qmsm~fenum    = qmfe~fenum
                                  AND qmsm~kzloesch = space
*Inicio - S 7000044969: INC30163664 - Lentidão YSPM_TEXTOS - ABAPXZL0 - 25/09/2017
* Por procedimento determina-se que 1 Medida tem n Ações associadas a esta Medida pelo Nr da Ação = Nr da Medida (QMMA-QMANUM=QMSM-QSMNUM)
* Relacionamento pelo Nr externo da Ação = Nr externo da Medida (ao realizar o DELETE ADJACENTS posterior somente manterá a 1a Ação da Medida)
       LEFT OUTER JOIN qmma ON qmma~qmnum    = qmsm~qmnum   " Nota - ações (1 item -> n ações)
                           AND qmma~fenum    = qmsm~fenum
                           AND qmma~qmanum   = qmsm~qsmnum
                           AND qmma~kzloesch = space
*Fim    - S 7000044969: INC30163664 - Lentidão YSPM_TEXTOS - ABAPXZL0 - 25/09/2017
  APPENDING CORRESPONDING FIELDS OF TABLE lcol_med
*  >> 7000038155: TICKETGD-1486 roberto fim
  WHERE qmel~qmnum      IN qmnum_m
    AND qmel~qmart      IN lr_med_qmart
    AND qmel~qmdat      IN lr_med_qmdat
    AND qmel~qmdab      IN lr_med_qmdab    " Data de encerramento da nota (vide comentários acima)
    AND qmel~rbnr       IN rbnr_m          " Perfil de catálogo
    AND qmih~equnr      IN equnr_m
    AND qmel~aufnr      IN aufnr_m
    AND qmel~qmtxt      IN qmtxt_m
    AND qmel~priok      IN priok_m
    AND qmel~qmnam      IN qmnam_m         " Autor da Nota
    AND qmel~arbpl      IN arbpl_m         " Centro de Trabalho responsável da Nota
    AND qmel~arbplwerk  IN vawrk_m
    AND qmih~iwerk      IN iwerk_m
    AND qmih~ingrp      IN ingpr_m
    AND qmih~ausvn      IN ausvn_m
    AND qmih~ausbs      IN ausbs_m
    AND qmih~btpln      IN btpln_m
    AND qmih~bequi      IN bequi_m
    AND qmel~ernam      IN ernam_m
    AND qmel~erdat      IN erdat_m
    AND qmel~prueflos   IN pruef_m
    AND iloa~tplnr      IN strno_m
    AND iloa~swerk      IN swerk_m         " Centro de localização (Nota) [da Nota da Medida] [vide acima]
    AND iloa~stort      IN stort_m         " Localização (Nota) [da Nota da Medida]
    AND iloa~beber      IN beber_m         " Área Operacional
    AND iloa~abckz      IN abckz_m         " Código ABC
    AND iloa~kostl      IN kostl_m         " Centro de custo (Nota) [da Nota da Medida]
    AND qmsm~fenum      IN fenum_m         " Identificador interno da Parte (Nº item no registro do item)
    AND qmsm~matxt      IN matxt_m
    AND qmsm~mngrp      IN mngrp_m
    AND qmsm~mncod      IN mncod_m
    AND qmsm~pster      IN pster_m
    AND qmsm~peter      IN peter_m
    AND qmsm~pstur      IN pstur_m
    AND qmsm~petur      IN petur_m
    AND qmsm~erlnam     IN erlnam_m
    AND qmsm~erldat     IN erldat_m
    AND qmsm~wdvdat     IN wdvdat_m
    AND qmsm~parnr      IN parnr_m
    AND qmsm~parvw      IN parvw_m
  AND qmsm~yyaufnr    IN yaufnr_m.
*  >> 7000038155: TICKETGD-1486 roberto inicio
*      %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
*  >> 7000038155: TICKETGD-1486 roberto fim
  CONSTANTS cc_hints_1 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.


  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*  " ..........................................................................
*  " Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
*  " ..........................................................................
*  IF rb_dem = 'X' AND dy_dme = 'X' .
*    " Se não houver Ordens informadas no filtro de Ordem atribuída à Medida (yaufnr_m[]), busca Notas para agregar/adicionar a lista de Medidas (APPEND)
*    " IMPORTANTE: CÓPIA do SQL ORIGINAL 'NOTAS (SQL PRINCIPAL)' onde DEVEM SER MANTIDOS a cláusula FROM+JOINS e SELECT e foram adicionadas colunas na cláusula WHERE devido ao filtro diferente
*    IF yaufnr_m[] IS INITIAL.
*      SELECT
*       qmel~qmnum           " Nº da nota
*       qmel~qmart           " Tipo de nota
*       qmel~aufnr           " Nº ordem
*       qmel~qmtxt           " Texto breve
*       qmel~objnr           " Nº objeto para administração de status
*       qmel~phase           " Fase de processamento nota
*       qmel~artpr           " Tipo de prioridade
*       qmel~priok           " Prioridade
*       qmel~qmnam           " Autor da Nota
*       qmel~qmdat           " Data da nota
*       qmel~indtx           " Existe texto descritivo para o objeto
*       qmel~rbnr            " Perfil de catálogo
*       qmel~erdat           " Data de criação
*       qmel~aenam           " Nome do responsável pela modificação do objeto
*       qmel~aedat           " Data da última modificação
*       qmel~arbpl           " Centro de trabalho responsável
*       qmel~yyimpacto_falha " Id Impacto Falha (Nota)  [snapshot do Impacto Falha do Local de Instalação (iflot~yyimpacto_falha) no momento da criação da Nota]
*       qmih~ingrp           " Grupo de planejamento para serviços cliente e manutenção
*       qmih~iwerk           " Centro planejamento
*       iloa~tplnr           " Local de Instalação
*       iloa~swerk           " Centro de localização (Nota) [snapshot do Centro de Localização do Local de Instalação (iflot~yycentro ou ILOA-SWERK do próprio Local) no momento da criação da Nota]
*       iloa~stort           " Localização (Nota)
*       iloa~abckz           " Código ABC
*       iflot~tplkz          " Código da estrutura do loc.instalação
*       iflotx~pltxt         " Denominação do loc.instalação
*       iflot~yyimpacto_falha as yyimpacto_falha_local  " Id Impacto Falha (Local)        [vide 'Id Impacto Falha (Nota)']
*       qmih~equnr           " Equipamento
*       eqkt~eqktx           " Denominação do objeto técnico (Equipamento)
*       qmih~warpl           " Plano de manutenção (se a Nota tiver plano)
*       mpla~wptxt           " Texto do plano de manutenção
*       qmih~bautl           " Conjunto
*       iloa~kokrs           " Área de contabilidade de custos
*       iloa~kostl           " Centro de custo (Nota)
*       iloa~eqfnr           " Campo de seleção
*       iloa~beber           " Área operacional
*       iloa~proid           " Elemento PEP Interno
*       qmel~kunum           " Nº  conta do cliente
*       qmel~kzmla           " Código: Segmento de texto em idioma principal
*       qmel~adrnr           " Endereços: nº do endereço
*       qmih~ausvn           " Início avaria
*       qmih~ausbs           " Fim da avaria
*       qmih~btpln           " Local instal.afetado
*       qmih~bequi           " Equipamento afetado
*       qmih~msaus           " Parada  CENÁRIO ESPECIAL ONDE LISTA-SE MEDIDAS E NOTAS (PARADA NÃO É UTILIZADA EM NOTA ZR DE MEDIDA)
*       qmih~auszt           " Duração da parada
*       qmih~maueh           " Unidade de tempo para a duração da parada
*       qmel~prueflos        " Lote de Controle
*       qmel~qmkat           " Tipo de catálogo da Nota        (NÃO SERÁ APRESENTADO/NÃO ESTÁ NO FIELDCATALOG - SIMILAR A IW28)
*       qmel~qmgrp           " Grupo do catálogo da Nota
*       qmel~qmcod           " Código do catálogo da Nota
*       FROM qmel INNER JOIN qmih ON qmih~mandt   = qmel~mandt
*                                AND qmih~qmnum   = qmel~qmnum
*                 INNER JOIN iloa ON iloa~mandt   = qmih~mandt
*                                AND iloa~iloan   = qmih~iloan
*           LEFT OUTER JOIN iflot ON iflot~mandt  = iloa~mandt
*                                AND iflot~tplnr  = iloa~tplnr
*          LEFT OUTER JOIN iflotx ON iflotx~mandt = iloa~mandt
*                                AND iflotx~tplnr = iloa~tplnr
*                                AND iflotx~spras = sy-langu
*           LEFT OUTER JOIN eqkt  ON eqkt~mandt   = qmih~mandt
*                                AND eqkt~equnr   = qmih~equnr
*                                AND eqkt~spras   = sy-langu
*           LEFT OUTER JOIN mpla  ON mpla~mandt   = qmih~mandt
*                                AND mpla~warpl   = qmih~warpl
*                          APPENDING CORRESPONDING FIELDS OF TABLE lcol_med
*      WHERE qmel~qmnum    IN qmnum_m
*        AND qmel~qmart    IN lr_med_qmart
*        AND qmel~qmdat    IN lr_med_qmdat
*        AND qmel~qmdab    IN lr_med_qmdab    " Data de encerramento da nota (vide comentários acima)
*        AND iloa~tplnr    IN strno_m
*        AND iloa~swerk    IN swerk_m         " Centro de localização (Nota) [vide acima]
*        AND iloa~stort    IN stort_m         " Localização (Nota)
*        AND iloa~beber    IN beber_m         " Área Operacional
*        AND qmel~aufnr    IN aufnr_m
*        AND qmel~qmtxt    IN qmtxt_m
*        AND qmel~priok    IN priok_m
*        AND qmel~qmnam    IN qmnam_m         " Autor da Nota
*        AND qmel~arbpl    IN arbpl_m
*        AND qmel~arbplwerk IN vawrk_m
*        AND qmel~ernam    IN ernam_m
*        AND qmel~erdat    IN erdat_m
*        AND qmih~iwerk    IN iwerk_m
*        AND qmih~ingrp    IN ingpr_m
*        AND qmih~equnr    IN equnr_m
*        " ADICIONAL AO SQL ORIGINAL DE NOTAS: Dados da cláusula WHERE do filtro que não são utilizados no SQL ORIGINAL de onde foi copiado 'NOTAS (SQL PRINCIPAL)'
*        AND qmel~rbnr     IN rbnr_m          " Perfil de catálogo
*        AND qmel~prueflos IN pruef_m
*        AND qmih~ausvn    IN ausvn_m
*        AND qmih~ausbs    IN ausbs_m
*        AND qmih~btpln    IN btpln_m
*        AND qmih~bequi    IN bequi_m
*        AND iloa~abckz    IN abckz_m         " Código ABC
*        AND iloa~kostl    IN kostl_m         " Centro de custo (Nota)
**  >> 7000038155: TICKETGD-1486 roberto inicio
*      %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
**  >> 7000038155: TICKETGD-1486 roberto fim
*    ENDIF.
*
**PEDK9A5893 xu86-abapxzfe 23.01.2013 S 7000000860: Estabilização NTI 239012 - YSPM_TEXTOS
*    " Remove todas as Medidas de todas as Notas sem Ordem associada e Remove todas as Medidas sem Ordem atribuída/associada
*    DELETE lcol_med WHERE aufnr IS INITIAL AND yyaufnr IS INITIAL.
**PEDK9A5893 XU86-abapxzfe 23.01.2013 S 7000000860: Estabilização NTI 239012 - YSPM_TEXTOS
*  ENDIF.
  " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

  " Se não há dados de Medidas (e Notas para o cenário de Demandas), retorna
  IF lcol_med[] IS INITIAL.
    RETURN.
  ENDIF.


  " xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  " Parâmetro de filtro 'Apresentar somente 1ª Ação de cada Medida' - INÍCIO
  " xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  " Ordena-se pelo código da Nota (qmnum) + Número da Medida [externo](m_qsmnum) + Identificador interno da Medida (m_manum)
  " + Número da Ação [externo] (a_qmanum) + Identificador interno da Ação (a_manum)
  " + Número da Causa [externo] (qurnum)  + Identificador interno da Causa (urnum)
  " para que ao deletar as linhas repetidas da mesma MEDIDA (se estiver marcado) ou da mesma AÇÃO DA MEDIDA (se NÃO estiver marcado),
  " mantenha somente uma única linha para a respectiva MEDIDA (e garantindo somente a 1a Ação da Medida) ou
  " uma única linha para a respectiva AÇÃO DA MEDIDA (todas Ações da Medida)
  " e nos 2 casos apresentando SOMENTE A 1A CAUSA da Parte da MEDIDA

*  Início - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
*  SORT lcol_med BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.
  SORT lcol_med BY qmnum ASCENDING m_qsmnum ASCENDING m_manum ASCENDING a_qmanum ASCENDING a_manum DESCENDING qurnum ASCENDING urnum ASCENDING.
*  Fim... - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59

  " Se estiver marcado (p_md_1ac = ABAP_TRUE):
  " O relatório de MEDIDAS deve OBRIGATORIAMENTE apresentar uma ÚNICA LINHA para cada MEDIDA forçando que seja apresentada apenas uma única Ação (se existir) da respectiva Medida
  IF p_md_1ac = abap_true.
    " DELETAR as linhas repetidas da mesma MEDIDA (qmnum m_qsmnum m_manum), GARANTINDO QUE somente seja mantida 1 única linha para cada MEDIDA
    " mantendo assim SOMENTE A 1A AÇÃO associada à respectiva MEDIDA
    DELETE ADJACENT DUPLICATES FROM lcol_med COMPARING qmnum m_qsmnum m_manum.

    " SENÃO, se NÃO estiver marcado (p_md_1ac = ABAP_FALSE):
    " O relatório de MEDIDAS deve OBRIGATORIAMENTE apresentar uma ÚNICA LINHA para cada AÇÃO DA MEDIDA apresentando todas as Ações associadas (se existirem) à respectiva Medida
  ELSE.
    " DELETAR as linhas repetidas da mesma AÇÃO DA MEDIDA (qmnum m_qsmnum m_manum a_qmanum a_manum), GARANTINDO QUE somente seja mantida 1 única linha para cada AÇÃO DA MEDIDA
    " mantendo assim TODAS AÇÕES associada à respectiva MEDIDA
    DELETE ADJACENT DUPLICATES FROM lcol_med COMPARING qmnum m_qsmnum m_manum a_qmanum a_manum.
  ENDIF.
  " xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  " Parâmetro de filtro 'Apresentar somente 1ª Ação de cada Medida' - FIM
  " xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


  " Busca todos os CodeGroups ref a ProbFalha, Parte, Defeito, Causa, Medida e Ação ( 'X', 'B', '9', 'Z', '2', 'A' )
  DATA: ti_qpgt   TYPE HASHED TABLE OF qpgt WITH UNIQUE KEY primary_key COMPONENTS katalogart codegruppe sprache,
        lstr_qpgt LIKE LINE OF ti_qpgt.
  SELECT * FROM qpgt INTO TABLE ti_qpgt
   WHERE katalogart IN ( 'X', 'B', '9', 'Z', '2', 'A' )
  AND sprache = sy-langu.

  " Busca todos os Códigos de todos os CodeGroups ref a ProbFalha, Parte, Defeito, Causa, Medida e Ação ( 'X', 'B', '9', 'Z', '2', 'A' )
  DATA: ti_qpct   TYPE HASHED TABLE OF qpct WITH UNIQUE KEY primary_key COMPONENTS katalogart codegruppe code sprache version,
        lstr_qpct LIKE LINE OF ti_qpct.
  SELECT * FROM qpct INTO TABLE ti_qpct
   WHERE katalogart IN ( 'X', 'B', '9', 'Z', '2', 'A' )
     AND sprache = sy-langu
  AND version = '000001'.

  " Busca o Histórico de Status para a Medida corrente dentro do LOOP (sofrendo REFRESH a cada iteração)
  DATA: ti_jcds_objnr   TYPE HASHED TABLE OF jcds WITH UNIQUE KEY primary_key COMPONENTS objnr stat chgnp chgnr,
        lstr_jcds_objnr LIKE LINE OF ti_jcds_objnr.

* Início - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
  PERFORM f_status_medida USING lcol_med.
  PERFORM f_busca_log_criticidade USING lcol_med.
* Fim... - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59

  "...........................................................................................................
  " Percorre cada Medida selecionando as compatíveis com os filtro indiretos E buscando dados adicionais
  "...........................................................................................................
  LOOP AT lcol_med INTO DATA(lstr_med).
    " Se filtro 'Incluir Medidas sem Catálogo (sem Código da Medida)' estiver DESMARCADO/NÃO (p_med_cd = ABAP_FALSE), ignora a Medida sem Código (lstr_med-m_mngrp IS INITIAL)
    IF p_med_cd = abap_false AND lstr_med-m_mngrp IS INITIAL. " ABAPMFP3 - 28.04.2019 - Medida sem Catálogo e respectivo FLAG desmarcado. NÃO LISTAR
      CONTINUE.
    ENDIF.

*   Início - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
    READ TABLE ti_stat_medida TRANSPORTING NO FIELDS WITH KEY objnr = lstr_med-m_objnr BINARY SEARCH.
    IF sy-subrc = 0.
      LOOP AT ti_stat_medida ASSIGNING FIELD-SYMBOL(<fs_stat>) FROM sy-tabix.
        IF <fs_stat>-objnr <> lstr_med-m_objnr.
          EXIT.
        ENDIF.

        CASE <fs_stat>-stat.
          WHEN gc_medida_ustatuscode_ph.
            lstr_med-yyphdata = <fs_stat>-udate.
          WHEN gc_medida_ustatuscode_canc.
            lstr_med-m_dtcancel = <fs_stat>-udate.
            lstr_med-m_hrcancel = <fs_stat>-utime.
          WHEN gc_medida_ustatuscode_elim.
            lstr_med-m_dtelim = <fs_stat>-udate.
            lstr_med-m_hrelim = <fs_stat>-utime.
          WHEN gc_medida_ustatuscode_emelabor.
            lstr_med-yyinitdata = <fs_stat>-udate.
          WHEN gc_medida_ustatuscode_ctec.
            lstr_med-yyctecdata = <fs_stat>-udate.
          WHEN gc_medida_ustatuscode_recb.
            lstr_med-yyrecbdata = <fs_stat>-udate.
          WHEN gc_medida_sytatuscode_sucess.
            lstr_med-yymsucdata = <fs_stat>-udate.
*        Início - SAPPMMN-608 - 12/12/2023 - F4SG
          WHEN gc_medida_sytatuscode_mede.
            lstr_med-yymmededata = <fs_stat>-udate.
          WHEN gc_medida_sytatuscode_medl.
            lstr_med-yymmedldata = <fs_stat>-udate.
          WHEN gc_medida_sytatuscode_meda.
            lstr_med-yymmedadata = <fs_stat>-udate.
*        Fim - SAPPMMN-608 - 12/12/2023 - F4SG
          WHEN OTHERS.
        ENDCASE.
      ENDLOOP.
    ENDIF.
*   Aplica o filtro "Só medidas com statu PH
    IF p_ph = abap_true AND lstr_med-yyphdata IS INITIAL.
      CONTINUE.
    ENDIF.

*   Filtro por data de cancelamentado da medida
    IF lstr_med-m_dtcancel IS INITIAL.
      IF cancdt_m IS NOT INITIAL.
        CONTINUE.
      ENDIF.
    ELSEIF cancdt_m IS NOT INITIAL.
      IF lstr_med-m_dtcancel NOT IN cancdt_m. "Se a data de cancelamento não corresponder ao filtro descarta o registro
        CONTINUE.
      ENDIF.
    ENDIF.

*   Filtro por data de eliminação da medida
    IF lstr_med-m_dtelim IS INITIAL.
      IF elimdt_m IS NOT INITIAL.
        CONTINUE.
      ENDIF.
    ELSEIF elimdt_m IS NOT INITIAL.
      IF lstr_med-m_dtelim NOT IN elimdt_m. "Se a data de cancelamento não corresponder ao filtro descarta o registro
        CONTINUE.
      ENDIF.
    ENDIF.

    DATA(lc_chave) = sy-mandt && lstr_med-qmnum && lstr_med-m_manum.
    READ TABLE ti_log_criticidade ASSIGNING FIELD-SYMBOL(<fs_crit>) WITH KEY chave     = lc_chave
                                                                             value_new = lstr_med-m_mncod BINARY SEARCH.
    IF sy-subrc = 0.
      lstr_med-crit_usuario = <fs_crit>-usuario.
      lstr_med-crit_data    = <fs_crit>-data.
      lstr_med-crit_hora    = <fs_crit>-hora.
    ENDIF.
*   Fim... - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59

    "............................................................................
    " Busca e seta os textos de Status de Sistema e Status de Usuário da MEDIDA
    "............................................................................
    CLEAR: lc_medida_status_line, lc_medida_userstat_line, lstr_med-m_msttxt, lstr_med-m_muttxt.
    CLEAR: lstr_status_syst_user_aux.
    CALL FUNCTION 'STATUS_TEXT_EDIT'
      EXPORTING
        flg_user_stat    = 'X'
        objnr            = lstr_med-m_objnr " OBJNR da Medida
        spras            = sy-langu
        bypass_buffer    = 'X'
      IMPORTING
        line             = lc_medida_status_line
        user_line        = lc_medida_userstat_line
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    lstr_med-m_msttxt = lc_medida_status_line.
    lstr_med-m_muttxt = lc_medida_userstat_line.

    CONCATENATE lc_medida_status_line lc_medida_userstat_line INTO lstr_status_syst_user_aux SEPARATED BY space.  "12/04/2013   ABAPY6HJ   7000002493

    "............................................................................
    " Busca e seta os textos de Status de Sistema e Status de Usuário da NOTA
    "............................................................................
    CLEAR: lc_notif_status_line, lc_notif_userstat_line, lstr_med-sttxt, lstr_med-ustxt.
    CALL FUNCTION 'STATUS_TEXT_EDIT'
      EXPORTING
        flg_user_stat    = 'X'
        objnr            = lstr_med-objnr     " OBJNR da Nota
        spras            = sy-langu
        bypass_buffer    = 'X'
      IMPORTING
        line             = lc_notif_status_line
        user_line        = lc_notif_userstat_line
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      CONTINUE.
    ENDIF.

    lstr_med-sttxt = lc_notif_status_line.
    lstr_med-ustxt = lc_notif_userstat_line.

    " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*    " ..........................................................................
*    " Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
*    " ..........................................................................
*    " Acrescenta na String de Status para realizar o filtro por Status inclusivo e exclusivo
*    IF rb_dem = 'X' AND dy_dme = 'X' .
*      CONCATENATE lstr_status_syst_user_aux lc_notif_status_line lc_notif_userstat_line INTO lstr_status_syst_user_aux SEPARATED BY space.
*    ENDIF.
    " ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###

    " IMPORTANTE: Por Decisão de Projeto de Software visando otimização de performance, utilizamos o texto de 40 chars
    "             do Status de Sistema e Status de Usuário da Medida, que no contexto atual (fev-2020) por serem numerados não estão sujeitos
    "             a overflow/estouro, para realizar os filtros de Status Inclusivo, Status Exclusivo e Medidas não-concluídas
    " Filtro "Apenas Medidas não-concluídas (inclusive Medidas 'SEM SUCESSO')" estiver MARCADO/SIM (p_med_nc=X)
    IF p_med_nc = abap_true.
      " Se a Medida estiver concluída (MEDE) e não for SEM SUCESSO (SSUC) OU
      " se a Medida estiver MREL (ELIMINADA com MREL ou CANCELADA com MREL - vide DTE) ignora, pula para próxima,
      " pois somente deve considerar medidas não-concluídas (inclusive Medidas 'SEM SUCESSO')
      IF ( lc_medida_status_line   CS yspm_constants_if=>e_medida_systemstatus_txt04-cc_mede AND
           lc_medida_userstat_line NS yspm_constants_if=>e_medida_userstatus_txt04-cc_sem_sucesso ) OR
         ( lc_medida_status_line   CS yspm_constants_if=>e_medida_systemstatus_txt04-cc_mrel ).
        CONTINUE.
      ENDIF.
    ENDIF.

    " Filtro 'Status Inclusivo - Medidas'
    CLEAR lstr_status_aux.
    IF stai1_m IS NOT INITIAL.
      wc_exit = abap_true.
      LOOP AT stai1_m.
        TRANSLATE stai1_m-low TO UPPER CASE.
        CONCATENATE '*' stai1_m-low '*' INTO lstr_status_aux.
        " Se a Medida corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Inclusivo, MANTÉM a Medida (wc_exit = ABAP_FALSE)
        " Obs.: Inclusive Status de Notas para cenário de relatório de DEMANDAS
        IF lstr_status_syst_user_aux CP lstr_status_aux.
          wc_exit = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF wc_exit = abap_true.
        CONTINUE.
      ENDIF.
    ENDIF.

    " Filtro 'Status Exclusivo - Medidas'
    CLEAR lstr_status_aux.
    IF stae1_m IS NOT INITIAL.
      wc_exit = abap_false.
      LOOP AT stae1_m.
        TRANSLATE stae1_m-low TO UPPER CASE.
        CONCATENATE '*' stae1_m-low '*' INTO lstr_status_aux.
        " Se a Medida corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Exclusivo, IGNORA/REMOVE a Medida (wc_exit = ABAP_TRUE)
        " Obs.: Inclusive Status de Notas para cenário de relatório de DEMANDAS
        IF lstr_status_syst_user_aux CP lstr_status_aux.
          wc_exit = abap_true.
          EXIT.
        ENDIF.
      ENDLOOP.

      IF wc_exit = abap_true.
        CONTINUE.
      ENDIF.
    ENDIF.


*   Início - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
*  " ---------------------------------------------------------------------------------------------------------------------------------------------------------
*  " Busca o histórico de Status da Medida corrente (lstr_med-m_objnr) para determinar suas datas INIT, CTEC, PH, RECB e MSUC
*  " ---------------------------------------------------------------------------------------------------------------------------------------------------------
*  " IMPORTANTE: Futuramente, pode ser considerada uma REFATORAÇÃO POR PERFORMANCE utilizado FOR ALL ENTRIES a partir ITable de OBJNRs das Medidas
*  " IMPORTANTE: Utilizamos somente chgnr = '1' para buscar a 1a ocorrência/registro do Status ignorando se foi registrado como Ativo ou Inativo (comentamos inact <> ' ')
*  "             dessa forma, contempla-se o cenário onde a ativação e inativação do Status é realizado no mesmo momento, criando uma única linha inativa (INACT = X)
*  REFRESH ti_jcds_objnr. CLEAR lstr_jcds_objnr.
*  CLEAR: lstr_med-yyinitdata, lstr_med-yyctecdata, lstr_med-yyphdata, lstr_med-yyrecbdata, lstr_med-yymsucdata.
*  SELECT * FROM jcds
*    INTO TABLE ti_jcds_objnr
*   WHERE objnr = lstr_med-m_objnr
*     AND ( stat = lc_medida_ustatuscode_emelabor OR stat = lc_medida_ustatuscode_ctec OR
*           stat = lc_medida_ustatuscode_ph       OR stat = lc_medida_ustatuscode_recb OR stat = yspm_constants_if=>e_medida_systemstatus_stat-successful )
*  AND chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001.
*    "   AND inact <> ' '.
**     %_HINTS ORACLE '&MAX_BLOCKING_FACTOR 50&'            "7000059731
**     ORACLE '&MAX_IN_BLOCKING_FACTOR 50&'.                "7000059731
*    CONSTANTS cc_hints_4 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.
*
*    " IMPORTANTE: ATUALMENTE NÃO CONSIDERA o CENÁRIO DE MÚLTIPLAS MUDANÇAS DE STATUS EM UMA ÚNICA ITERAÇÃO/GRAVAÇÃO (sem registro de histórico dos Status intermediários) [vide doc model Notification]
*    "             Vide implementação similar no Portal MI que busca a data/usuário de aprovação e grava na tabela expressa (YSPMPEMIMEDIDA-YYDATA_APROV YSPMPEMIMEDIDA-YYRESP_APROV)
*    "             O conceito engloba o Status de Aprovação (PH) e todos outros status intermediários (INIT, CTEC, PH, RECB) com seus registros de histórico de status buscados nesse relatório
*    IF ti_jcds_objnr[] IS NOT INITIAL.
**      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH TABLE KEY primary_key COMPONENTS objnr = lstr_med-m_objnr
*      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH KEY                              objnr = lstr_med-m_objnr
*                                                                                          stat  = lc_medida_ustatuscode_emelabor                              " INIT
**                                                                                          inact = abap_false
*                                                                                          chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                                          chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001. " Talvez CHGNR seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
*      IF sy-subrc = 0.
*        lstr_med-yyinitdata = lstr_jcds_objnr-udate.
*      ELSE.
*        LOOP AT ti_jcds_objnr INTO lstr_jcds_objnr WHERE objnr = lstr_med-m_objnr                                AND
*                                                         stat  = lc_medida_ustatuscode_emelabor                  AND
**                                                         inact = abap_false                                      AND
*                                                       ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                                                         chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
*          lstr_med-yyinitdata = lstr_jcds_objnr-udate.
*          EXIT.
*        ENDLOOP.
*      ENDIF.
*
**      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH TABLE KEY primary_key COMPONENTS objnr = lstr_med-m_objnr
*      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH KEY                              objnr = lstr_med-m_objnr
*                                                                                          stat  = lc_medida_ustatuscode_ctec
*                                                                                          inact = abap_false                                  " CTEC
*                                                                                          chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                                          chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001. " Talvez CHGNR seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
*      IF sy-subrc = 0.
*        lstr_med-yyctecdata = lstr_jcds_objnr-udate.
*      ELSE.
*        LOOP AT ti_jcds_objnr INTO lstr_jcds_objnr WHERE objnr = lstr_med-m_objnr                                AND
*                                                         stat  = lc_medida_ustatuscode_ctec                      AND
*                                                         inact = abap_false                                      AND
*                                                       ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                                                         chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
*          lstr_med-yyctecdata = lstr_jcds_objnr-udate.
*          EXIT.
*        ENDLOOP.
*      ENDIF.
*
**      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH TABLE KEY primary_key COMPONENTS objnr = lstr_med-m_objnr
*      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH KEY                              objnr = lstr_med-m_objnr
*                                                                                          stat  = lc_medida_ustatuscode_ph                         " PH
*                                                                                          inact = abap_false
*                                                                                          chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                                          chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001. " Talvez CHGNR seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
*      IF sy-subrc = 0.
*        lstr_med-yyphdata = lstr_jcds_objnr-udate.
*      ELSE.
*        LOOP AT ti_jcds_objnr INTO lstr_jcds_objnr WHERE objnr = lstr_med-m_objnr                                AND
*                                                         stat  = lc_medida_ustatuscode_ph                        AND
*                                                         inact = abap_false                                      AND
*                                                       ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                                                         chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
*          lstr_med-yyphdata = lstr_jcds_objnr-udate.
*          EXIT.
*        ENDLOOP.
*      ENDIF.
*
**      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH TABLE KEY primary_key COMPONENTS objnr = lstr_med-m_objnr
*      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH KEY                              objnr = lstr_med-m_objnr
*                                                                                          stat  = lc_medida_ustatuscode_recb                      " RECB
*                                                                                          inact = abap_false
*                                                                                          chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                                          chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001. " Talvez CHGNR seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
*      IF sy-subrc = 0.
*        lstr_med-yyrecbdata = lstr_jcds_objnr-udate.
*      ELSE.
*        LOOP AT ti_jcds_objnr INTO lstr_jcds_objnr WHERE objnr = lstr_med-m_objnr                                AND
*                                                         stat  = lc_medida_ustatuscode_recb                      AND
*                                                         inact = abap_false                                      AND
*                                                       ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001 OR
*                                                         chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
*          lstr_med-yyrecbdata = lstr_jcds_objnr-udate.
*          EXIT.
*        ENDLOOP.
*      ENDIF.
*
**      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH TABLE KEY primary_key COMPONENTS objnr = lstr_med-m_objnr
*      READ TABLE ti_jcds_objnr INTO lstr_jcds_objnr WITH KEY                              objnr = lstr_med-m_objnr
*                                                                                          stat  = yspm_constants_if=>e_medida_systemstatus_stat-successful    " MSUC - Medida CONCLUIDA COM SUCESSO
*                                                                                          inact = abap_false
*                                                                                          chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001
*                                                                                          chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001. " Talvez CHGNR seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
*      IF sy-subrc = 0.
*        lstr_med-yymsucdata = lstr_jcds_objnr-udate.
*      ELSE.
*        LOOP AT ti_jcds_objnr INTO lstr_jcds_objnr WHERE objnr = lstr_med-m_objnr                                         AND
*                                                         stat  = yspm_constants_if=>e_medida_systemstatus_stat-successful AND
*                                                         inact = abap_false                                               AND
*                                                       ( chgnp = yspm_constants_if=>e_status-cc_status_chgnp_001          OR
*                                                         chgnr = yspm_constants_if=>e_status-cc_status_chgnr_001 ).
*          lstr_med-yymsucdata = lstr_jcds_objnr-udate.
*          EXIT.
*        ENDLOOP.
*      ENDIF.
*    ENDIF.
*   Fim... - S7000114003: ACROSSAP-53 - 27/09/2023 - XX59
    .
    " ---------------------------------------------------------------------------------------------------------------------------------------------------------
    " Busca textos do Grupo de códigos e do Código de PROBFALHA, PARTE, DEFEITO, CAUSA, MEDIDA e AÇÃO da Medida corrente
    " ---------------------------------------------------------------------------------------------------------------------------------------------------------
    " IMPORTANTE: FUTURAMENTE implementar controle por cada ENTIDADE/CATÁLOGO que permita utilizar os mesmos textos até mudar a PARTE/DEFEITO no loop (ou melhor até mudar Grupo de códigos e Código)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos da PROBFALHA (qmkat=X)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-qmgrp IS NOT INITIAL OR lstr_med-qmcod IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos da PROBFALHA (qmkat=X)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-qmkat
                                                                              codegruppe = lstr_med-qmgrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-txt_qmgrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código da PROBFALHA (qmkat=X)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-qmkat
                                                                              codegruppe = lstr_med-qmgrp
                                                                              code       = lstr_med-qmcod
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-txt_qmcod = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.

    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos da PARTE (otkat=B)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-m_otgrp IS NOT INITIAL OR lstr_med-m_oteil IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos da PARTE (otkat=B)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_otkat
                                                                              codegruppe = lstr_med-m_otgrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_otgrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código da PARTE (otkat=B)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_otkat
                                                                              codegruppe = lstr_med-m_otgrp
                                                                              code       = lstr_med-m_oteil
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_oteil = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.

    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos do DEFEITO (fekat=9)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-m_fegrp IS NOT INITIAL OR lstr_med-m_fecod IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos do DEFEITO (fekat=9)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_fekat
                                                                              codegruppe = lstr_med-m_fegrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_fegrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código do DEFEITO (fekat=9)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_fekat
                                                                              codegruppe = lstr_med-m_fegrp
                                                                              code       = lstr_med-m_fecod
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_fecod = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.

    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos da CAUSA (urkat=Z)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-urgrp IS NOT INITIAL OR lstr_med-urcod IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos da CAUSA (urkat=Z)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-urkat
                                                                              codegruppe = lstr_med-urgrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-txt_urgrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código da CAUSA (urkat=Z)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-urkat
                                                                              codegruppe = lstr_med-urgrp
                                                                              code       = lstr_med-urcod
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-txt_urcod = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.

    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos da MEDIDA (mnkat=2)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-m_mngrp IS NOT INITIAL OR lstr_med-m_mncod IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos da MEDIDA (mnkat=2)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_mnkat
                                                                              codegruppe = lstr_med-m_mngrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_mngrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código da MEDIDA (mnkat=2)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-m_mnkat
                                                                              codegruppe = lstr_med-m_mngrp
                                                                              code       = lstr_med-m_mncod
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-m_txt_mncod = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.

    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    " Textos da AÇÃO (mnkat=A)
    " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    IF lstr_med-a_mngrp IS NOT INITIAL OR lstr_med-a_mncod IS NOT INITIAL.    " Teoricamente, os 2 são preenchidos ou os 2 NÃO preenchidos
      " Texto do Grupo de códigos da AÇÃO (mnkat=A)
      READ TABLE ti_qpgt INTO lstr_qpgt WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-a_mnkat
                                                                              codegruppe = lstr_med-a_mngrp
                                                                              sprache    = sy-langu.  " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-a_txt_mngrp = lstr_qpgt-kurztext.
      ENDIF.

      " Texto do código da AÇÃO (mnkat=A)
      READ TABLE ti_qpct INTO lstr_qpct WITH TABLE KEY primary_key COMPONENTS katalogart = lstr_med-a_mnkat
                                                                              codegruppe = lstr_med-a_mngrp
                                                                              code       = lstr_med-a_mncod
                                                                              sprache    = sy-langu   " Talvez SPRACHE seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
                                                                              version    = '000001'.  " Talvez VERSION seja irrelevante para a busca pela PRIMARY KEY em HASHED TABLE
      IF sy-subrc = 0.
        lstr_med-a_txt_mncod = lstr_qpct-kurztext.
      ENDIF.
    ENDIF.


    " .............................................................................................................................
    " Preenche o Nome da função responsável pela Medida (lstr_med-m_vtext)
    " .............................................................................................................................
    CLEAR: lstr_med-m_vtext.
    IF lstr_med-m_parnr IS NOT INITIAL.
      CALL FUNCTION 'PM_PARTNER_READ' ##FM_SUBRC_OK
        EXPORTING
          parvw  = lstr_med-m_parvw
          parnr  = lstr_med-m_parnr
        IMPORTING
          vtext  = lstr_med-m_vtext
        EXCEPTIONS
          OTHERS = 1.
    ENDIF.

    " ......................................................................................................................................
    " Preenche o campo 'Localização da Medida/Nota' (lstr_med-yystort) e 'Descrição da Localização da Medida/Nota' (lstr_med-yystort_ktext)
    " com a Localização da Medida (lstr_med-yystort) ou com a Localização da Nota (lstr_med-stort) (nesta sequência de prioridade)
    " ......................................................................................................................................
    " IMPORTANTE: FUTURAMENTE implementar a apresentação dos 2 campos: Localização da Medida e Localização da Nota para evitar interpretação indevida da informação
    CLEAR: lstr_med-yystort_ktext.
    IF lstr_med-yystort IS NOT INITIAL OR lstr_med-stort IS NOT INITIAL.
      IF lstr_med-yystort IS NOT INITIAL.
        SELECT SINGLE ktext              "#EC CI_NOORDER or "#EC WARNOK
          INTO lstr_med-yystort_ktext
          FROM t499s
        WHERE stand = lstr_med-yystort.            " A 'Localização da Medida/Nota' se mantém como a Localização da Medida
      ELSE. " IF lstr_med-stort IS NOT INITIAL.
        SELECT SINGLE ktext              "#EC CI_NOORDER or "#EC WARNOK
          INTO lstr_med-yystort_ktext
          FROM t499s
        WHERE stand = lstr_med-stort.
        lstr_med-yystort = lstr_med-stort.          " Seta a 'Localização da Medida/Nota' com a Localização da Nota
      ENDIF.
    ENDIF.

    " .............................................................................................................................
    " Preenche Centro de Trabalho responsável da Nota
    " .............................................................................................................................
    " IMPORTANTE: FUTURAMENTE implementar controle por NOTA que permite utilizar o mesmo Centro de Trabalho até mudar a Nota no loop (ou melhor quando mudar o prórpio CenTrab resp da Nota)
    IF lstr_med-arbpl IS NOT INITIAL.
      CALL FUNCTION 'CR_WORKSTATION_READ' ##FM_SUBRC_OK
        EXPORTING
          id        = CONV rcr01-arbid( lstr_med-arbpl )
          msgty     = 'S'
        IMPORTING
          arbpl     = ls_ugewrk_aux
          ktext     = lstr_med-arbpl_ktext
          werks     = ls_uwerk_aux          " NÃO UTILIZADO
        EXCEPTIONS
          not_found = 1.
    ENDIF.
    IF lstr_med-arbpl_ktext IS NOT INITIAL.
      lstr_med-vaplz = ls_ugewrk_aux.
    ENDIF.

    " Inclusão da Medida selecionada na OUTPUT ITable
    APPEND lstr_med TO gcol_medout.
  ENDLOOP.

  " Se não há dados de Medidas (e Notas para o cenário de Demandas), retorna
  IF gcol_medout[] IS INITIAL.
*    message s641(ysf).
    RETURN.
  ELSE.
    " Filtro 'Responsável', remove as Medidas que não estiverem no filtro informado
    IF parnr_m IS NOT INITIAL.
      DELETE gcol_medout WHERE vaplz NOT IN parnr_m.
    ENDIF.

    " Filtro 'Data PH', remove as Medidas que não estiverem no filtro informado
    IF phdat_m IS NOT INITIAL.
      DELETE gcol_medout WHERE yyphdata NOT IN phdat_m.
    ENDIF.

    " Filtro 'Data RECB', remove as Medidas que não estiverem no filtro informado
    IF recbdt_m IS NOT INITIAL.
      DELETE gcol_medout WHERE yyrecbdata NOT IN recbdt_m.
    ENDIF.

    " Filtro 'Data MSUC', remove as Medidas que não estiverem no filtro informado
    IF msucdt_m IS NOT INITIAL.
      DELETE gcol_medout WHERE yymsucdata NOT IN msucdt_m.
    ENDIF.
  ENDIF.
ENDFORM.                    " F_SSCRGETDATA_MED

*&---------------------------------------------------------------------*
*&      Form  F_SSCRGETDATA_OPE
*&---------------------------------------------------------------------*
FORM f_sscrgetdata_ope.
  DATA: lc_oper_status_line       TYPE bsvx-sttxt,
        lc_oper_userstat_line     TYPE bsvx-sttxt,
        lstr_status_aux           TYPE string,
        lstr_status_syst_user_aux TYPE string.
  DATA: l_date LIKE sy-datum.                               "7000059731

*".........................................................................................................
*"   Construção de RANGE de Datas do período informado no filtro (Data de Referência da Operacao)
*".........................................................................................................
*" Na iw38 a Data de Referência é a Data de Referência da Ordem (na coluna afih-addat) definida através do Status da Ordem  na lógica de gravação da iw32
  RANGES: lr_ope_addat FOR afih-addat.   " Range das datas do período do filtro
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Inicio*
*-----------------------------------------------------------------------------------------------*

*" Se uma das datas do período foi informada, seta as variáveis de período de acordo com o filtro informado e insere o intervalo no RANGE
*" Senão, se as datas não foram informadas, nada faz. O RANGE ficará vazio e o período não será considerado como filtro no SQL

  IF NOT datuv_o IS INITIAL OR NOT datub_o IS INITIAL.
*"  Se somente a data final foi informada, seta a data inicial com a data-base do SAP
    IF datuv_o IS INITIAL AND NOT datub_o IS INITIAL.
      datuv_o = '19000101'.

*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datub_o                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '-'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datuv_o = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731

*"  Se somente a data inicial foi informada, seta a data final com a data-teto do SAP
    IF NOT datuv_o IS INITIAL AND datub_o IS INITIAL.
      datub_o = '99991231'.

*      clear: l_date.                                        "7000059731
*      call function 'RP_CALC_DATE_IN_INTERVAL'  "7000059731
*        exporting                               "7000059731
*          date      = datuv_o                   "7000059731
*          days      = 0                         "7000059731
*          months    = 0                         "7000059731
*          signum    = '+'                       "7000059731
*          years     = 1                         "7000059731
*        importing                               "7000059731
*          calc_date = l_date.                   "7000059731
*
*      datub_o = l_date.                                     "7000059731
    ENDIF.                                                  "7000059731

*" Insere o intervalo (BETWEEN = BT) da data inicial e data final
    lr_ope_addat-low    = datuv_o.
    lr_ope_addat-high   = datub_o.
    lr_ope_addat-sign   = 'I'.
    lr_ope_addat-option = 'BT'.
    APPEND lr_ope_addat.
*-----------------------------------------------------------------------------------------------*
* 24/01/2019 | ABAPY6IC | S 7000061017: INC36689874 - Correção YSPM_TEXTOS              * Fim   *
*-----------------------------------------------------------------------------------------------*

  ELSEIF datuv_o IS INITIAL OR datub_o IS INITIAL.

*          Grp.plnj.PM                Centro planejament         Ordem
*        Se os tres primeiros estiverem em branco
    IF ( ( ingpr_o-low IS INITIAL AND     iwerk_o-low IS INITIAL AND aufnr_o-low = ' ' ) OR
*        Se os tres primeiros estiverem com asterisco
    ( ingpr_o-low = '*'      AND     iwerk_o-low = '*'      AND aufnr_o-low = '*' ) OR
*        Se os dois estiverem em branco e o terceiro com asterisco
    ( ingpr_o-low IS INITIAL AND     iwerk_o-low IS INITIAL AND aufnr_o-low = '*' ) ) AND
*        Centro de trabalho
    ( arbpl_o-low IS INITIAL ) AND
*        Centro
    ( werks_o-low IS INITIAL ) AND
*        Tipo de ordem
    ( auart_o[] IS INITIAL AND
*        Data de referência operação
    ( datuv_o IS INITIAL   OR
    datub_o IS INITIAL ) AND
*        Operação
    ( vornr_o-low IS INITIAL ) AND
*        Texto breve operação
    ( ltxa1_o-low IS INITIAL ) AND
*        Local de instalação
    ( tplnr_o-low IS INITIAL ) AND
*        Equipamento
    ( equnr_o-low IS INITIAL ) AND
*        Material
    ( sermat_o-low IS INITIAL ) AND
*        Nº de série
    ( serial_o-low IS INITIAL ) AND
*        Campo de seleção
    ( eqfnr_o-low IS INITIAL ) AND
*        Chave de controle
    ( steus_o-low IS INITIAL ) AND
*        Status inclusivo
    ( stai1_op-low IS INITIAL ) AND
*        Status exclusivo
    ( stae1_op-low IS INITIAL ) AND
*        1ª data de início
    ( fsavd_o-low IS INITIAL ) AND
*        1ª data fim
    ( fsedd_o-low IS INITIAL ) AND
*        Última data início
    ( ssavd_o-low IS INITIAL ) AND
*        Data do início real
    ( isdd_o-low IS INITIAL ) AND
*        Data do fim real
    ( iedd_o-low IS INITIAL ) ).

      lr_ope_addat-low    = sy-datum.
      lr_ope_addat-high   = datub_o.
      lr_ope_addat-sign   = 'I'.
      lr_ope_addat-option = 'GE'.
      APPEND lr_ope_addat.

*     Favor informar algum parâmetro de seleção.
*     Filtro com Data de referência maior que hoje.
      MESSAGE i016(ys_pm) WITH TEXT-234 TEXT-235.
    ENDIF.

  ENDIF.

*"...............................................................
*"   Construção de RANGE de Status da Ordem informados no filtro
*"...............................................................
*" Obs.: A Ordem tem seus Status refletidos no campo AFIH-IPHAS o que permite na tx iw38
*"       que as consultas utilizem esta coluna para seleção de Status informados no filtro (Nota é diferente)
*"       ABER-0 LIB-2 ENTE-3 ENCE-6 MREL-4 (iphas=4 -somente é incluído quando selecionado no filtro #encerrado#)
  RANGES: lr_orderopestatus_iphas FOR afih-iphas.

* " aberto: Status CREATED (ABER)
  lr_orderopestatus_iphas-low    = c_orderstatus_iphas-created.
  lr_orderopestatus_iphas-sign   = 'I'.
  lr_orderopestatus_iphas-option = 'EQ'.
  APPEND lr_orderopestatus_iphas.

* " em procmnto: Status RELEASED (LIB)
  lr_orderopestatus_iphas-low    = c_orderstatus_iphas-released.
  lr_orderopestatus_iphas-sign   = 'I'.
  lr_orderopestatus_iphas-option = 'EQ'.
  APPEND lr_orderopestatus_iphas.

* " encerrado: Status TCOMPLETED (ENTE) or Status CLOSED (ENCE)
  lr_orderopestatus_iphas-low    = c_orderstatus_iphas-tcompleted.
  lr_orderopestatus_iphas-sign   = 'I'.
  lr_orderopestatus_iphas-option = 'EQ'.
  APPEND lr_orderopestatus_iphas.

  lr_orderopestatus_iphas-low    = c_orderstatus_iphas-closed.
  lr_orderopestatus_iphas-sign   = 'I'.
  lr_orderopestatus_iphas-option = 'EQ'.
  APPEND lr_orderopestatus_iphas.

  lr_orderopestatus_iphas-low    = c_orderstatus_iphas-eliminated.
  lr_orderopestatus_iphas-sign   = 'I'.
  lr_orderopestatus_iphas-option = 'EQ'.
  APPEND lr_orderopestatus_iphas.

  " -----------------------------------------------------------------
  " Seleção de Ordens compatíveis com os dados informados no filtro
  " -----------------------------------------------------------------

  DATA: ti_qmel          TYPE TABLE OF qmel WITH HEADER LINE.
  DATA: lcol_operacoes   TYPE TABLE OF ty_operacoes.
  DATA: lstr_operacoes   LIKE LINE OF lcol_operacoes.
  DATA: lcol_sooperacoes TYPE TABLE OF ty_operacoes.
  DATA: v_name_oper      LIKE thead-tdname.
  DATA: ti_lines         LIKE tline OCCURS 0 WITH HEADER LINE.
  DATA: lc_txt_str       TYPE string.       " variavel para concatenar txt longo

*          Tabela aufk
  SELECT                                                "#EC CI_NOORDER
   aufk~aufnr       "ordem
  aufk~auart       "tipo da ordem
  aufk~vaplz       "Centro de trabalho
  aufk~objnr       "Nº objeto
  aufk~waers       "Moeda da ordem
  aufk~werks       "Centro de Localização
*          Tabela afko
  afko~aufpl       "Nº de roteiro de operações na ordem
*          Tabela afih
  afih~iwerk       "Centro planejamento
  afih~ingpr       "GRP.PLNJ.PM
  afih~addat       "Data de Refeência
  afih~iwerk       "Centro
*          Tabela qmel
  qmel~qmnum       "Nota
  qmel~qmart       "Tipo da Nota
  qmel~qmtxt       "Texto breve da nota
  qmel~qmart       "Tipo de nota
*          Tabela iloa
  iloa~eqfnr       "Campo de seleção
  iloa~tplnr       "Local de Instalação
  iloa~stort       "Localização [Localização da Ordem]
*          Tabela iflot
  iflot~tplkz      "Código da estrutura do loc.instalação
*          Tabela iflotx
  iflotx~pltxt     "Denominação do loc.instalação
*          Tabela eqkt
  eqkt~eqktx       "Denominação do objeto técnico (Equipamento)
*          Tabela afvc
  afvc~aufpl       "Nº de roteiro de operações na ordem
  afvc~aplzl       "Numerador geral da ordem
  afvc~vornr       "Operação
  afvc~ltxa1       "Texto breve operação
  afvc~steus       "Chave de controle
*          Tabela afvv
  afvv~fsavd       "1ª data de início
  afvv~fsedd       "1ª data fim
  afvv~ssavd       "Última data início
  afvv~isdd        "Início real: execução (data)
  afvv~iedd        "Fim real: executar (data)

  INTO CORRESPONDING FIELDS OF TABLE lcol_operacoes
  FROM ( ( ( ( ( ( ( ( ( aufk INNER JOIN afko ON afko~mandt   = aufk~mandt
                                             AND afko~aufnr   = aufk~aufnr )
                              INNER JOIN afih ON afih~mandt   = aufk~mandt
                                             AND afih~aufnr   = aufk~aufnr )
                              INNER JOIN afvc ON afvc~aufpl   = afko~aufpl )
                              INNER JOIN afvv ON afvv~aufpl   = afvc~aufpl
                                             AND afvv~aplzl   = afvc~aplzl )
                         LEFT OUTER JOIN qmel ON qmel~mandt   = aufk~mandt
                                             AND qmel~aufnr   = aufk~aufnr )
                              INNER JOIN iloa ON iloa~mandt   = afih~mandt
                                             AND iloa~iloan   = afih~iloan )
                        LEFT OUTER JOIN iflot ON iflot~mandt  = iloa~mandt
                                             AND iflot~tplnr  = iloa~tplnr )
                       LEFT OUTER JOIN iflotx ON iflotx~mandt = iloa~mandt
                                             AND iflotx~tplnr = iloa~tplnr
                                             AND iflotx~spras = sy-langu   )
                         LEFT OUTER JOIN eqkt ON eqkt~mandt   = afih~mandt
                                             AND eqkt~equnr   = afih~equnr
                                             AND eqkt~spras   = sy-langu )
  WHERE aufk~aufnr    IN aufnr_o       "Ordem
    AND aufk~auart    IN auart_o       "Tipo de Ordem
    AND aufk~vaplz    IN arbpl_o       "Centro de trabalho
    AND aufk~yymatnr  IN sermat_o      "Material
    AND aufk~werks    IN werks_o       "Centro Localização
    AND afih~iwerk    IN iwerk_o       "Centro planejamento
    AND afih~ingpr    IN ingpr_o       "Grp.plnj.PM
    AND afih~addat    IN lr_ope_addat  "Data de Referência
    AND afih~serialnr IN serial_o      "No série
    AND afih~equnr    IN equnr_o       "Equipamento
    AND afih~sermat   IN sermat_o      "Material
    AND afih~iphas    IN lr_orderopestatus_iphas  "status
    AND iloa~eqfnr    IN eqfnr_o       "Campo de seleção
    AND iloa~tplnr    IN tplnr_o       "Local de Instalação
    AND afvc~vornr    IN vornr_o       "Operação
    AND afvc~ltxa1    IN ltxa1_o       "Texto breve operacao
    AND afvc~steus    IN steus_o       "Chave de controle
    AND afvc~loekz    NE 'X'           "Não marcado para eliminar
    AND afvc~equnr    IN equnr_o       "Equipamento
    AND afvv~fsavd    IN fsavd_o       "1ª data de início
    AND afvv~fsedd    IN fsedd_o       "1ª data fim
    AND afvv~ssavd    IN ssavd_o       "Última data início
    AND afvv~isdd     IN isdd_o        "Início real: execução (data)
  AND afvv~iedd     IN iedd_o.       "Fim real: executar (data)
*  >> 7000038155: TICKETGD-1486 roberto inicio
*      %_HINTS ORACLE '&SUBSTITUTE VALUES&'.
*  >> 7000038155: TICKETGD-1486 roberto fim
  CONSTANTS cc_hints_1 TYPE c VALUE ysca_s4h_pendencia=>cc_hints_oracle.

  IF sy-subrc = 0.

*"----------------------------------------------------------------------------------------
*" Seleção de Ordens compatíveis com os filtros indiretos e inclusão na OUTPUT ITable
*"----------------------------------------------------------------------------------------
    RANGES: lr_operacoes_objnr FOR aufk-objnr.             " Performance para SELECTs
*"..........................................................................
*" Percorre cada Ordem buscando seus Status de Sistema e Usuário
*"..........................................................................
    CLEAR:   gcol_operacoesout.
    REFRESH: gcol_operacoesout.
                                                        "#EC CI_NOORDER
    LOOP AT lcol_operacoes INTO lstr_operacoes.
*     "..........................................................................
*     " Busca e seta os textos de Status de Sistema e Status de Usuário da Ordem
*     "..........................................................................
      CALL FUNCTION 'STATUS_TEXT_EDIT'
        EXPORTING
          flg_user_stat    = 'X'
          objnr            = lstr_operacoes-objnr
          spras            = sy-langu
          bypass_buffer    = 'X'
        IMPORTING
          line             = lc_oper_status_line        " Status do sistema da Ordem
          user_line        = lc_oper_userstat_line   " Status do usuário da Ordem
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.

      IF sy-subrc EQ 0.
        CLEAR: lstr_status_syst_user_aux.
        CONCATENATE lc_oper_status_line lc_oper_userstat_line INTO lstr_status_syst_user_aux SEPARATED BY space.

        " Filtro 'Status Inclusivo - Operação'
        IF stai1_op IS NOT INITIAL.
          wc_exit = abap_true.
          LOOP AT stai1_op.
            TRANSLATE stai1_op-low TO UPPER CASE.
            CONCATENATE '*' stai1_op-low '*' INTO lstr_status_aux.
            " Se a Operação corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Inclusivo, MANTÉM a Operação (wc_exit = ABAP_FALSE)
            IF lstr_status_syst_user_aux CP lstr_status_aux.
              wc_exit = abap_false.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF wc_exit = abap_true.
            CONTINUE.
          ENDIF.
        ENDIF.

        " Filtro 'Status Exclusivo - Operação'
        IF stae1_op IS NOT INITIAL.
          wc_exit = abap_false.
          LOOP AT stae1_op.
            TRANSLATE stae1_op-low TO UPPER CASE.
            CONCATENATE '*' stae1_op-low '*' INTO lstr_status_aux.
            " Se a Operação corrente tem algum de seus Status de Sistema e/ou Status de Usuário nos valores de filtro de Status Exclusivo, IGNORA/REMOVE a Operação (wc_exit = ABAP_TRUE)
            IF lstr_status_syst_user_aux CP lstr_status_aux.
              wc_exit = abap_true.
              EXIT.
            ENDIF.
          ENDLOOP.

          IF wc_exit = abap_true.
            CONTINUE.
          ENDIF.
        ENDIF.

        lstr_operacoes-vsttxt = lc_oper_status_line.
        lstr_operacoes-vsttxu = lc_oper_userstat_line.
        CLEAR: lc_oper_status_line, lc_oper_userstat_line, lstr_status_aux.

      ELSE.
        CLEAR: lstr_operacoes-vsttxt, lstr_operacoes-vsttxu.
        CONTINUE.
      ENDIF.
*

*"    Inclusão da Ordem selecionada no RANGE de Ordens selecionadas
      lr_operacoes_objnr-low    = lstr_operacoes-objnr.
      lr_operacoes_objnr-sign   = 'I'.
      lr_operacoes_objnr-option = 'EQ'.

      APPEND lr_operacoes_objnr.


      CLEAR lstr_operacoes-ktext2.
      IF lstr_operacoes-stort IS NOT INITIAL.
        SELECT SINGLE ktext              "#EC CI_NOORDER or "#EC WARNOK
        INTO lstr_operacoes-ktext2
        FROM t499s
        WHERE stand = lstr_operacoes-stort.
      ENDIF.
                                                        "#EC CI_NOORDER
      APPEND lstr_operacoes TO gcol_operacoesout.
    ENDLOOP.

*   Auxiliar para buscar Status
    DATA: lv_objnr LIKE viafvc-objnr,
          sttxt    LIKE bsvx-sttxt, " Status de sistema
          sttxu    LIKE bsvx-sttxt, " Status de usuario
          vsttxt   LIKE bsvx-sttxt, "Lista de status da operação
          vsttxu   LIKE bsvx-sttxt. "Lista de status da operação

    SORT lcol_operacoes BY objnr.

    LOOP AT lcol_operacoes INTO lstr_operacoes.

      lv_objnr = lstr_operacoes-objnr.

      CALL FUNCTION 'STATUS_TEXT_EDIT' ##FM_SUBRC_OK
        EXPORTING
          client        = sy-mandt
          objnr         = lv_objnr
          spras         = sy-langu
          flg_user_stat = 'X'
          only_active   = 'X'
          bypass_buffer = 'X'   "Deixar marcado para atualizar no Refresh!!!
        IMPORTING
          line          = sttxt
          user_line     = sttxu
        EXCEPTIONS
          OTHERS        = 1.

      CLEAR:   v_name_oper, ti_lines, lc_txt_str.
      REFRESH: ti_lines.

      CONCATENATE sy-mandt lstr_operacoes-aufpl lstr_operacoes-aplzl INTO v_name_oper.

      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = 'AVOT'
          language                = sy-langu
          name                    = v_name_oper
          object                  = 'AUFK'
        TABLES
          lines                   = ti_lines
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.

      IF sy-subrc <> 0.
*          MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ELSE.
        MOVE 'X' TO lstr_operacoes-char01.
      ENDIF.

      lstr_operacoes-vsttxt = sttxt.
      lstr_operacoes-vsttxu = sttxu.
      MODIFY lcol_operacoes FROM lstr_operacoes
      TRANSPORTING vsttxt vsttxu char01.
    ENDLOOP.


    gcol_operacoesout[] = lcol_operacoes[].

*    Se não existem dados na OUTPUT ITable, retorna
    IF gcol_operacoesout[] IS INITIAL.
*      message i641(ysf).
      RETURN.
    ENDIF.
  ENDIF.

ENDFORM.                    " F_SSCRGETDATA_OPE
*&---------------------------------------------------------------------*
*&      Form  F_SSCRGETDATA_lis
*&---------------------------------------------------------------------*
FORM f_sscrgetdata_lis.

  DATA: BEGIN OF texto,
          mandt	TYPE mandt,
          plnty	TYPE plnty,
          plnnr	TYPE plnnr,
          plnal	TYPE plnal,
          zaehl	TYPE cim_count,
        END OF texto.

  DATA v_name_lis     LIKE thead-tdname.
  DATA: ti_lines      LIKE tline OCCURS 0 WITH HEADER LINE,
        lstr_listaout LIKE LINE OF gcol_listaout.

                                                        "#EC CI_NOORDER
  SELECT * FROM tca01 WHERE flg_equi NE ' '
                      OR    flg_ifl  NE ' '
                      OR    flg_inst NE ' '.
    MOVE-CORRESPONDING tca01 TO tca01_tab.
    APPEND tca01_tab.
  ENDSELECT.

  DATA: h_ktext LIKE plko-ktext.
  DATA: ht_tapl_r LIKE v_tapl_iflos OCCURS 0 WITH HEADER LINE.
  DATA: BEGIN OF h_selfields_tab OCCURS 20,
          field(72),
        END OF h_selfields_tab.

*---create selfields_tab for selection
  APPEND 'MANDT'    TO h_selfields_tab.
  APPEND 'TPLNR'    TO h_selfields_tab.
  APPEND 'PLNTY'    TO h_selfields_tab.
  APPEND 'PLNNR'    TO h_selfields_tab.
  APPEND 'PLNAL'    TO h_selfields_tab.

  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      text = 'Arbeitsplanselektion'(201).
*--- Konvertierungsexit T.P. berücksichtigen ------------------------*
*  perform check_tplnr_f16 tables pn_strno
*                                 pn_tplnr
*                          using  g_x.
* falls Selektionsdatum initial, Heute-Datum einsetzen
  IF pn_datuv IS INITIAL.
    pn_datuv = sy-datum.
  ENDIF.

*--- Groß und Kleinschreibung bei Kurztext ignorieren ----------------
  SET LOCALE LANGUAGE sy-langu.
  LOOP AT ktext.
    TRANSLATE ktext-low TO UPPER CASE.                   "#EC TRANSLANG
    TRANSLATE ktext-high TO UPPER CASE.                  "#EC TRANSLANG
    MODIFY ktext.
  ENDLOOP.

  CLEAR g_arbpl_flag.
  CLEAR object_tab1.
  REFRESH object_tab1.
  REFRESH plko_r.
* Arbeitsplan lesen
  IF NOT pn_ihan IS INITIAL.           "IH-Anleitung
    IF NOT ind_stat IS INITIAL.
      REFRESH l_t_plko.

      SELECT * FROM plko INTO TABLE l_t_plko
                         WHERE plnty EQ plnty_anl
*A&D WPS External Number & Parameter hierarchical tasklist      "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   tl_extid IN pn_extid             "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*A&D PM/PS reference element integration                        "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   adpsp IN adpsp                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   plnnr IN pn_plnnr
                         AND   plnal IN pn_plnal
                         AND   datuv LE pn_datuv
                         AND   aennr IN aennr
                         AND   andat IN andat
*                           and   annam in annam
*                           and   aedat in aedat
*                           and   aenam in aenam
                         AND   verwe IN verwe
                         AND   werks IN werks
*                       and   statu in statu <<<< without
                         AND   vagrp IN vagrp
                         AND   kokrs IN kokrs
                         AND   strat IN strat
                         AND   istru IN istru
                         AND   anlzu IN anlzu.
* Filter according to selection-parameter PN_HIRTL              "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
* Filter only if task list selection screen is displayed        "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*        if not dy_mode is initial.                      "N1109961  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          if pn_hirtl eq 'X'.                                       "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            delete l_t_plko where xhiertl ne 'X'.                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          else.                                                     "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            delete l_t_plko where xhiertl eq 'X'.                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          endif.                                                    "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*        endif.                                          "N1109961  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }


*    sort l_t_plko to find the newest entry
      SORT l_t_plko BY plnty
                       plnnr
                       plnal
                       datuv DESCENDING.

      CLEAR: l_plnty, l_plnnr, l_plnnr.

*    loop at l_t_plko to catch the newest entries
      LOOP AT l_t_plko.
        IF l_t_plko-plnty <> l_plnty OR
           l_t_plko-plnnr <> l_plnnr OR
           l_t_plko-plnal <> l_plnal.
*    check the status wheter task list is released to
*    include or not
          IF l_t_plko-statu IN statu.
            MOVE l_t_plko TO plko.
            h_ktext = plko-ktext.
            TRANSLATE h_ktext TO UPPER CASE.             "#EC TRANSLANG
            CHECK h_ktext IN ktext.
            PERFORM move_plko_to_object_tab_l.
          ENDIF.
        ENDIF.
        l_plnty = l_t_plko-plnty.
        l_plnnr = l_t_plko-plnnr.
        l_plnal = l_t_plko-plnal.
      ENDLOOP.
    ELSE.

      SELECT * FROM plko WHERE plnty EQ plnty_anl
                         AND   plnnr IN pn_plnnr
                         AND   plnal IN pn_plnal
                         AND   datuv LE pn_datuv
*A&D WPS External Number Parameter hierarchical tasklist  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   tl_extid IN pn_extid       "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*A&D PM/PS reference element integration                  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   adpsp IN adpsp             "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   aennr IN aennr
*                        and   loekz eq space
                         AND   andat IN andat
*                           and   annam in annam
*                           and   aedat in aedat
*                           and   aenam in aenam
                         AND   verwe IN verwe
                         AND   werks IN werks
                         AND   statu IN statu
                         AND   vagrp IN vagrp
                         AND   kokrs IN kokrs
                         AND   strat IN strat
                         AND   istru IN istru
                         AND   anlzu IN anlzu.

** Filter according to selection-parameter PN_HIRTL        "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          if pn_hirtl = 'X'.                                "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            if plko-xhiertl ne 'X'.                         "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*              continue.                                     "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            endif.                                          "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          else.                                             "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            if plko-xhiertl eq 'X'.                         "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*              continue.                                     "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            endif.                                          "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          endif.                                            "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }

        h_ktext = plko-ktext.
        TRANSLATE h_ktext TO UPPER CASE.                 "#EC TRANSLANG
        CHECK h_ktext IN ktext.
        PERFORM move_plko_to_object_tab_l.
      ENDSELECT.

    ENDIF.
  ENDIF.

  IF NOT pn_iflo IS INITIAL.           "TP-Plan
    CLEAR object_tab1.
    REFRESH tapl_r.
    CLEAR   tapl_r.
    READ TABLE pn_tplnr INDEX 1.

*--- if G_ALTERN_ACT is activ use speial views
    IF g_altern_act = g_x AND NOT pn_strno[] IS INITIAL.
      g_viewname = 'V_TAPL_IFLOS'.
      APPEND 'TPLNR_INT' TO h_selfields_tab.
    ELSE.
      g_viewname = 'TAPL'.
    ENDIF.

    SELECT (h_selfields_tab) FROM (g_viewname)
           INTO CORRESPONDING FIELDS OF TABLE ht_tapl_r
                       WHERE tplnr IN pn_strno
                       AND   plnty EQ plnty_tpl
                       AND   plnnr IN pn_plnnr
                       AND   plnal IN pn_plnal
                       AND   iwerk IN werks
                       AND   datuv LE pn_datuv
*                      AND   aennr IN aennr   "N1103200
                       AND   loekz EQ space
                       AND   andat IN andat.
*                         and   annam in annam.
    IF sy-subrc IS INITIAL.
      LOOP AT ht_tapl_r.
        MOVE-CORRESPONDING ht_tapl_r TO tapl_r.
        IF g_altern_act = g_x AND NOT pn_strno[] IS INITIAL.
          tapl_r-tplnr = ht_tapl_r-tplnr_int.
        ENDIF.
        APPEND tapl_r.
      ENDLOOP.
* Überprüfen ob Liste über Wartungsplan bzw. Auftrag gerufen
* Wenn ja löschen Inhalt Liste Baugruppen aus Selektionsbild
* für individuelle Selektion
      IF NOT sy-calld  IS INITIAL.
        IF sy-tcode CP 'IP*' OR
           sy-tcode CP 'IW*'.
          CLEAR istru.
          REFRESH istru.
        ENDIF.
      ENDIF.
      SORT tapl_r BY plnnr plnal.
*       perform move_tapl_to_object_tab_l.
      IF NOT ind_stat IS INITIAL.
        REFRESH l_t_plko.


        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko INTO TABLE l_t_plko
                   FOR ALL ENTRIES IN tapl_r
                   WHERE plnty = tapl_r-plnty
*A&D WPS External Number
* Parameter hierarchical tasklist
                   AND   tl_extid IN pn_extid
*A&D PM/PS reference element integration
                   AND   adpsp IN adpsp
                   AND   plnnr = tapl_r-plnnr
                   AND   plnal = tapl_r-plnal
                   AND   datuv LE pn_datuv
                   AND verwe IN verwe
                   AND werks IN werks
*                   and statu in statu <<<<without
                   AND vagrp IN vagrp
                   AND kokrs IN kokrs
                   AND strat IN strat
                   AND istru IN istru
                   AND anlzu IN anlzu.
* Filter according to selection-parameter PN_HIRTL
*          if pn_hirtl eq 'X'.
*            delete l_t_plko where xhiertl ne 'X'.
*          else.
*            delete l_t_plko where xhiertl eq 'X'.
*          endif.



*    sort l_t_plko to find the newest entry
        SORT l_t_plko BY plnty
                         plnnr
                         plnal
                         datuv DESCENDING.

        CLEAR: l_plnty, l_plnnr, l_plnnr.

*    loop at l_t_plko to catch the newest entries
        LOOP AT l_t_plko.
          IF l_t_plko-plnty <> l_plnty OR
            l_t_plko-plnnr <> l_plnnr OR
            l_t_plko-plnal <> l_plnal.
*    check the status wheter task list is released to
*    include or not
            IF l_t_plko-statu IN statu.
              MOVE l_t_plko TO plko.
              PERFORM append_object_tab_tapl.
            ENDIF.
            l_plnty = l_t_plko-plnty.
            l_plnnr = l_t_plko-plnnr.
            l_plnal = l_t_plko-plnal.
          ENDIF.
        ENDLOOP.
      ELSE.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko FOR ALL ENTRIES IN tapl_r
            WHERE plnty = tapl_r-plnty
*   A&D WPS External Number
*   & Parameter hierarchical tasklist
            AND   tl_extid IN pn_extid
*   A&D PM/PS reference element integration
            AND   adpsp IN adpsp
            AND   plnnr = tapl_r-plnnr
            AND   plnal = tapl_r-plnal
            AND   datuv LE pn_datuv
            AND   loekz = space
            AND verwe IN verwe
            AND werks IN werks
            AND statu IN statu
            AND vagrp IN vagrp
            AND kokrs IN kokrs
            AND strat IN strat
            AND istru IN istru
            AND anlzu IN anlzu
*              and   aedat in aedat                          "710142
*              and   aenam in aenam                          "710142
            AND aennr IN aennr                              "N1103200
            ORDER BY PRIMARY KEY.
* Filter according to selection-parameter PN_HIRTL
*            if pn_hirtl = 'X'.
*              if plko-xhiertl ne 'X'.
*                continue.
*              endif.
*            else.
*              if plko-xhiertl eq 'X'.
*                continue.
*              endif.
*            endif.
          PERFORM append_object_tab_tapl.
        ENDSELECT.

      ENDIF.
    ENDIF.
  ENDIF.
  IF NOT pn_equi IS INITIAL.
    CLEAR object_tab1.
    REFRESH eapl_r.
    CLEAR   eapl_r.
    READ TABLE pn_equnr INDEX 1.

    SELECT mandt equnr plnty plnnr plnal INTO TABLE eapl_r
        FROM eapl WHERE
                             equnr IN pn_equnr
                       AND   plnty EQ plnty_equi
                       AND   plnnr IN pn_plnnr
                       AND   plnal IN pn_plnal
                       AND   iwerk IN werks
                       AND   datuv LE pn_datuv
*                      AND   aennr IN aennr "N1103200
                       AND   loekz EQ space
                       AND   andat IN andat.
*                         and   annam in annam.

*     perform move_eapl_to_object_tab_l.
*  Wenn Eapl-Sätze vorhanden             ist SY-SUBRC <> 0
    IF sy-subrc IS INITIAL.
* Überprüfen ob Liste über Wartungsplan bzw. Auftrag gerufen
* Wenn ja löschen Inhalt Liste Baugruppen aus Selektionsbild
* für individuelle Selektion
      IF NOT sy-calld  IS INITIAL.
        IF sy-tcode CP 'IP*' OR
           sy-tcode CP 'IW*'.
          CLEAR istru.
          REFRESH istru.
        ENDIF.
      ENDIF.
      SORT eapl_r BY plnnr plnal.
      IF NOT ind_stat IS INITIAL.
        REFRESH l_t_plko.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko INTO TABLE l_t_plko
          FOR ALL ENTRIES IN eapl_r
          WHERE plnty = eapl_r-plnty
*         A&D WPS External Number
*         & Parameter hierarchical tasklist
          AND   tl_extid IN pn_extid
*         A&D PM/PS reference element integration
          AND   adpsp IN adpsp
          AND   plnnr = eapl_r-plnnr
          AND   plnal = eapl_r-plnal
          AND   datuv LE pn_datuv
          AND verwe IN verwe
          AND werks IN werks
*         and statu in statu <<<<without
          AND vagrp IN vagrp
          AND kokrs IN kokrs
          AND strat IN strat
          AND istru IN istru
          AND anlzu IN anlzu.
* Filter according to selection-parameter PN_HIRTL
*          if pn_hirtl eq 'X'.
*            delete l_t_plko where xhiertl ne 'X'.
*          else.
*            delete l_t_plko where xhiertl eq 'X'.
*          endif.
        "{ End ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }



*--- sort l_t_plko to find the newest entry
        SORT l_t_plko BY plnty
                         plnnr
                         plnal
                         datuv DESCENDING.

        CLEAR: l_plnty, l_plnnr, l_plnnr.

*--- loop at l_t_plko to catch the newest entries
        LOOP AT l_t_plko.
          IF l_t_plko-plnty <> l_plnty OR
            l_t_plko-plnnr <> l_plnnr OR
            l_t_plko-plnal <> l_plnal.
*--- check the status wheter task list is released to
*    include or not
            IF l_t_plko-statu IN statu.
              MOVE l_t_plko TO plko.
              PERFORM append_object_tab_eapl.
            ENDIF.
            l_plnty = l_t_plko-plnty.
            l_plnnr = l_t_plko-plnnr.
            l_plnal = l_t_plko-plnal.
          ENDIF.
        ENDLOOP.
      ELSE.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko FOR ALL ENTRIES IN eapl_r
                     WHERE plnty = eapl_r-plnty
*A&D WPS External Number
*& Parameter hierarchical tasklist
                     AND   tl_extid IN pn_extid
*A&D PM/PS reference element integration
                     AND   adpsp IN adpsp
                     AND   plnnr = eapl_r-plnnr
                     AND   plnal = eapl_r-plnal
                     AND   datuv LE pn_datuv
*                    and   loekz = space
                     AND verwe IN verwe
                     AND werks IN werks
                     AND statu IN statu
                     AND vagrp IN vagrp
                     AND kokrs IN kokrs
                     AND strat IN strat
                     AND istru IN istru
                     AND anlzu IN anlzu
*                       and   aedat in aedat                 "710142
*                       and   aenam in aenam                 "710142
                     AND aennr IN aennr                     "N1103200
                     ORDER BY PRIMARY KEY.
* Filter according to selection-parameter PN_HIRTL
*            if pn_hirtl = 'X'.
*              if plko-xhiertl ne 'X'.
*                continue.
*              endif.
*            else.
*              if plko-xhiertl eq 'X'.
*                continue.
*              endif.
*            endif.
          PERFORM append_object_tab_eapl.
        ENDSELECT.
        "{ End ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }


      ENDIF.
    ENDIF.
*   endselect.
  ENDIF.
  PERFORM delete_invalid_plko_l.
  PERFORM authority-check_l.
  PERFORM fill_object_tab_l.
  REFRESH plko_tmp.
*--- Defaultsortiertung wenn nichts über SALV eingestellt -----------
  SORT object_tab1 BY plnnr plnal.

  REFRESH gcol_listaout.

  IF object_tab1 IS NOT INITIAL.
    APPEND LINES OF object_tab1 TO  gcol_listaout.
    LOOP AT gcol_listaout INTO  lstr_listaout.
      texto-mandt = sy-mandt.
      texto-plnal = lstr_listaout-plnal.
      texto-plnnr = lstr_listaout-plnnr.
      texto-plnty = lstr_listaout-plnty.
      texto-zaehl = lstr_listaout-zaehl.
      v_name_lis  = texto." separated by space.

      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = 'PLKO'
          language                = sy-langu
          name                    = v_name_lis
          object                  = 'ROUTING'
        TABLES
          lines                   = ti_lines
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.

      IF sy-subrc <> 0.
*          MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*          WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ELSE.
        lstr_listaout-char01 = 'X'.
      ENDIF.
      MODIFY gcol_listaout FROM lstr_listaout.
    ENDLOOP.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  F_SSCRGETDATA_trf
*&---------------------------------------------------------------------*
FORM f_sscrgetdata_trf.

  DATA: BEGIN OF texto,
          mandt	TYPE mandt,
          plnty	TYPE plnty,
          plnnr	TYPE plnnr,
          plnkn	TYPE plnkn,
          zaehl	TYPE cim_count,
        END OF texto.

  DATA v_name_trf     LIKE thead-tdname.
  DATA: ti_lines      LIKE tline OCCURS 0 WITH HEADER LINE,
        lstr_trfout   LIKE LINE OF gcol_trfout,
        lstr_listaout LIKE LINE OF gcol_listaout.

                                                        "#EC CI_NOORDER
  SELECT * FROM tca01 WHERE flg_equi NE ' '
                      OR    flg_ifl  NE ' '
                      OR    flg_inst NE ' '.
    MOVE-CORRESPONDING tca01 TO tca01_tab.
    APPEND tca01_tab.
  ENDSELECT.

  DATA: h_ktext LIKE plko-ktext.
  DATA: ht_tapl_r LIKE v_tapl_iflos OCCURS 0 WITH HEADER LINE.
  DATA: BEGIN OF h_selfields_tab OCCURS 20,
          field(72),
        END OF h_selfields_tab.

*---create selfields_tab for selection
  APPEND 'MANDT'    TO h_selfields_tab.
  APPEND 'TPLNR'    TO h_selfields_tab.
  APPEND 'PLNTY'    TO h_selfields_tab.
  APPEND 'PLNNR'    TO h_selfields_tab.
  APPEND 'PLNAL'    TO h_selfields_tab.

  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
    EXPORTING
      text = 'Arbeitsplanselektion'(201).
*--- Konvertierungsexit T.P. berücksichtigen ------------------------*
*  perform check_tplnr_f16 tables pn_strno
*                                 pn_tplnr
*                          using  g_x.
* falls Selektionsdatum initial, Heute-Datum einsetzen
  IF pn_datuv IS INITIAL.
    pn_datuv = sy-datum.
  ENDIF.

*--- Groß und Kleinschreibung bei Kurztext ignorieren ----------------
  SET LOCALE LANGUAGE sy-langu.
  LOOP AT ktext.
    TRANSLATE ktext-low TO UPPER CASE.                   "#EC TRANSLANG
    TRANSLATE ktext-high TO UPPER CASE.                  "#EC TRANSLANG
    MODIFY ktext.
  ENDLOOP.

  CLEAR g_arbpl_flag.
  CLEAR object_tab1.
  REFRESH object_tab1.
  REFRESH plko_r.
* Arbeitsplan lesen
  IF NOT pn_ihant IS INITIAL.           "IH-Anleitung
    IF NOT ind_stat IS INITIAL.
      REFRESH l_t_plko.

      SELECT * FROM plko INTO TABLE l_t_plko
                         WHERE plnty EQ plnty_anl
*A&D WPS External Number & Parameter hierarchical tasklist      "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   tl_extid IN pnextidt             "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*A&D PM/PS reference element integration                        "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   adpsp IN adpsp_t                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   plnnr IN pnplnnrt
                         AND   plnal IN pnplnalt
                         AND   datuv LE pn_datuv
                         AND   aennr IN aennr_t
                         AND   andat IN andat_t
*                           and   annam in annam
*                           and   aedat in aedat
*                           and   aenam in aenam
                         AND   verwe IN verwe_t
                         AND   werks IN werks_t
*                       and   statu in statu <<<< without
                         AND   vagrp IN vagrp_t
                         AND   kokrs IN kokrs_t
                         AND   strat IN strat_t
                         AND   istru IN istru_t
                         AND   anlzu IN anlzu_t.
* Filter according to selection-parameter PN_HIRTL              "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
* Filter only if task list selection screen is displayed        "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*        if not dy_mode is initial.                      "N1109961  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          if pn_hirtl eq 'X'.                                       "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            delete l_t_plko where xhiertl ne 'X'.                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          else.                                                     "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*            delete l_t_plko where xhiertl eq 'X'.                   "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*          endif.                                                    "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*        endif.                                          "N1109961  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }


*    sort l_t_plko to find the newest entry
      SORT l_t_plko BY plnty
                       plnnr
                       plnal
                       datuv DESCENDING.

      CLEAR: l_plnty, l_plnnr, l_plnnr.

*    loop at l_t_plko to catch the newest entries
      LOOP AT l_t_plko.
        IF l_t_plko-plnty <> l_plnty OR
           l_t_plko-plnnr <> l_plnnr OR
           l_t_plko-plnal <> l_plnal.
*    check the status wheter task list is released to
*    include or not
          IF l_t_plko-statu IN statu.
            MOVE l_t_plko TO plko.
            h_ktext = plko-ktext.
            TRANSLATE h_ktext TO UPPER CASE.             "#EC TRANSLANG
            CHECK h_ktext IN ktext.
            PERFORM move_plko_to_object_tab_l.
          ENDIF.
        ENDIF.
        l_plnty = l_t_plko-plnty.
        l_plnnr = l_t_plko-plnnr.
        l_plnal = l_t_plko-plnal.
      ENDLOOP.
    ELSE.

      SELECT * FROM plko WHERE plnty EQ plnty_anl
                         AND   plnnr IN pnplnnrt
                         AND   plnal IN pnplnalt
                         AND   datuv LE pndatuvt
*A&D WPS External Number Parameter hierarchical tasklist  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   tl_extid IN pnextidt       "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
*A&D PM/PS reference element integration                  "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   adpsp IN adpsp_t             "{ ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
                         AND   aennr IN aennr_t
                         AND   andat IN andat_t
                         AND   verwe IN verwe_t
                         AND   werks IN werks_t
                         AND   statu IN statu_t
                         AND   vagrp IN vagrp_t
                         AND   kokrs IN kokrs_t
                         AND   strat IN strat_t
                         AND   istru IN istru_t
                         AND   anlzu IN anlzu_t.


        h_ktext = plko-ktext.
        TRANSLATE h_ktext TO UPPER CASE.
        CHECK h_ktext IN ktext.
        PERFORM move_plko_to_object_tab_l.
      ENDSELECT.

    ENDIF.
  ENDIF.

  IF NOT pn_iflot IS INITIAL.           "TP-Plan
    CLEAR object_tab1.
    REFRESH tapl_r.
    CLEAR   tapl_r.
    READ TABLE pntplnrt INDEX 1.

*--- if G_ALTERN_ACT is activ use speial views
    IF g_altern_act = g_x AND NOT pn_strno[] IS INITIAL.
      g_viewname = 'V_TAPL_IFLOS'.
      APPEND 'TPLNR_INT' TO h_selfields_tab.
    ELSE.
      g_viewname = 'TAPL'.
    ENDIF.

    SELECT (h_selfields_tab) FROM (g_viewname)
           INTO CORRESPONDING FIELDS OF TABLE ht_tapl_r
                       WHERE tplnr IN pnstrnot
                       AND   plnty EQ plnty_tpl
                       AND   plnnr IN pnplnnrt
                       AND   plnal IN pnplnalt
                       AND   iwerk IN werks_t
                       AND   datuv LE pndatuvt
*                      AND   aennr IN aennr   "N1103200
                       AND   loekz EQ space
                       AND   andat IN andat_t.
*                         and   annam in annam.
    IF sy-subrc IS INITIAL.
      LOOP AT ht_tapl_r.
        MOVE-CORRESPONDING ht_tapl_r TO tapl_r.
        IF g_altern_act = g_x AND NOT pnstrnot[] IS INITIAL.
          tapl_r-tplnr = ht_tapl_r-tplnr_int.
        ENDIF.
        APPEND tapl_r.
      ENDLOOP.
* Überprüfen ob Liste über Wartungsplan bzw. Auftrag gerufen
* Wenn ja löschen Inhalt Liste Baugruppen aus Selektionsbild
* für individuelle Selektion
      IF NOT sy-calld  IS INITIAL.
        IF sy-tcode CP 'IP*' OR
           sy-tcode CP 'IW*'.
          CLEAR istru.
          REFRESH istru.
        ENDIF.
      ENDIF.
      SORT tapl_r BY plnnr plnal.
*      perform move_tapl_to_object_tab_l.
      IF NOT ind_stat IS INITIAL.
        REFRESH l_t_plko.


        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko INTO TABLE l_t_plko
                   FOR ALL ENTRIES IN tapl_r
                   WHERE plnty = tapl_r-plnty
*A&D WPS External Number
* Parameter hierarchical tasklist
                   AND   tl_extid IN pn_extid
*A&D PM/PS reference element integration
                   AND   adpsp IN adpsp_t
                   AND   plnnr = tapl_r-plnnr
                   AND   plnal = tapl_r-plnal
                   AND   datuv LE pndatuvt
                   AND verwe IN verwe_t
                   AND werks IN werks_t
*                   and statu in statu <<<<without
                   AND vagrp IN vagrp_t
                   AND kokrs IN kokrs_t
                   AND strat IN strat_t
                   AND istru IN istru_t
                   AND anlzu IN anlzu_t.
* Filter according to selection-parameter PN_HIRTL
*          if pn_hirtl eq 'X'.
*            delete l_t_plko where xhiertl ne 'X'.
*          else.
*            delete l_t_plko where xhiertl eq 'X'.
*          endif.



*    sort l_t_plko to find the newest entry
        SORT l_t_plko BY plnty
                         plnnr
                         plnal
                         datuv DESCENDING.

        CLEAR: l_plnty, l_plnnr, l_plnnr.

*    loop at l_t_plko to catch the newest entries
        LOOP AT l_t_plko.
          IF l_t_plko-plnty <> l_plnty OR
            l_t_plko-plnnr <> l_plnnr OR
            l_t_plko-plnal <> l_plnal.
*    check the status wheter task list is released to
*    include or not
            IF l_t_plko-statu IN statu.
              MOVE l_t_plko TO plko.
              PERFORM append_object_tab_tapl.
            ENDIF.
            l_plnty = l_t_plko-plnty.
            l_plnnr = l_t_plko-plnnr.
            l_plnal = l_t_plko-plnal.
          ENDIF.
        ENDLOOP.
      ELSE.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko FOR ALL ENTRIES IN tapl_r
            WHERE plnty = tapl_r-plnty
*   A&D WPS External Number
*   & Parameter hierarchical tasklist
            AND   tl_extid IN pnextidt
*   A&D PM/PS reference element integration
            AND   adpsp IN adpsp_t
            AND   plnnr = tapl_r-plnnr
            AND   plnal = tapl_r-plnal
            AND   datuv LE pndatuvt
            AND   loekz = space
            AND verwe IN verwe_t
            AND werks IN werks_t
            AND statu IN statu_t
            AND vagrp IN vagrp_t
            AND kokrs IN kokrs_t
            AND strat IN strat_t
            AND istru IN istru_t
            AND anlzu IN anlzu_t
*              and   aedat in aedat                          "710142
*              and   aenam in aenam                          "710142
            AND aennr IN aennr_t                            "N1103200
            ORDER BY PRIMARY KEY.
* Filter according to selection-parameter PN_HIRTL
*            if pn_hirtl = 'X'.
*              if plko-xhiertl ne 'X'.
*                continue.
*              endif.
*            else.
*              if plko-xhiertl eq 'X'.
*                continue.
*              endif.
*            endif.
          PERFORM append_object_tab_tapl.
        ENDSELECT.

      ENDIF.
    ENDIF.
  ENDIF.
  IF NOT pn_equit IS INITIAL.
    CLEAR object_tab1.
    REFRESH eapl_r.
    CLEAR   eapl_r.
    READ TABLE pnequnrt INDEX 1.

    SELECT mandt equnr plnty plnnr plnal INTO TABLE eapl_r
        FROM eapl WHERE
                             equnr IN pnequnrt
                       AND   plnty EQ plnty_equi
                       AND   plnnr IN pnplnnrt
                       AND   plnal IN pnplnalt
                       AND   iwerk IN werks_t
                       AND   datuv LE pndatuvt
*                      AND   aennr IN aennr "N1103200
                       AND   loekz EQ space
                       AND   andat IN andat_t.
*                         and   annam in annam.

*     perform move_eapl_to_object_tab_l.
*  Wenn Eapl-Sätze vorhanden             ist SY-SUBRC <> 0
    IF sy-subrc IS INITIAL.
* Überprüfen ob Liste über Wartungsplan bzw. Auftrag gerufen
* Wenn ja löschen Inhalt Liste Baugruppen aus Selektionsbild
* für individuelle Selektion
      IF NOT sy-calld  IS INITIAL.
        IF sy-tcode CP 'IP*' OR
           sy-tcode CP 'IW*'.
          CLEAR istru.
          REFRESH istru.
        ENDIF.
      ENDIF.
      SORT eapl_r BY plnnr plnal.
      IF NOT ind_stat IS INITIAL.
        REFRESH l_t_plko.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko INTO TABLE l_t_plko
          FOR ALL ENTRIES IN eapl_r
          WHERE plnty = eapl_r-plnty
*         A&D WPS External Number
*         & Parameter hierarchical tasklist
          AND   tl_extid IN pn_extid
*         A&D PM/PS reference element integration
          AND   adpsp IN adpsp_t
          AND   plnnr = eapl_r-plnnr
          AND   plnal = eapl_r-plnal
          AND   datuv LE pndatuvt
          AND verwe IN verwe_t
          AND werks IN werks_t
*         and statu in statu <<<<without
          AND vagrp IN vagrp_t
          AND kokrs IN kokrs_t
          AND strat IN strat_t
          AND istru IN istru_t
          AND anlzu IN anlzu_t.
* Filter according to selection-parameter PN_HIRTL
*          if pn_hirtl eq 'X'.
*            delete l_t_plko where xhiertl ne 'X'.
*          else.
*            delete l_t_plko where xhiertl eq 'X'.
*          endif.
        "{ End ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }



*--- sort l_t_plko to find the newest entry
        SORT l_t_plko BY plnty
                         plnnr
                         plnal
                         datuv DESCENDING.

        CLEAR: l_plnty, l_plnnr, l_plnnr.

*--- loop at l_t_plko to catch the newest entries
        LOOP AT l_t_plko.
          IF l_t_plko-plnty <> l_plnty OR
            l_t_plko-plnnr <> l_plnnr OR
            l_t_plko-plnal <> l_plnal.
*--- check the status wheter task list is released to
*    include or not
            IF l_t_plko-statu IN statu.
              MOVE l_t_plko TO plko.
              PERFORM append_object_tab_eapl.
            ENDIF.
            l_plnty = l_t_plko-plnty.
            l_plnnr = l_t_plko-plnnr.
            l_plnal = l_t_plko-plnal.
          ENDIF.
        ENDLOOP.
      ELSE.



        "{ Begin ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }
        SELECT * FROM plko FOR ALL ENTRIES IN eapl_r
                     WHERE plnty = eapl_r-plnty
*A&D WPS External Number
*& Parameter hierarchical tasklist
                     AND   tl_extid IN pnextidt
*A&D PM/PS reference element integration
                     AND   adpsp IN adpsp_t
                     AND   plnnr = eapl_r-plnnr
                     AND   plnal = eapl_r-plnal
                     AND   datuv LE pndatuvt
*                    and   loekz = space
                     AND verwe IN verwe_t
                     AND werks IN werks_t
                     AND statu IN statu_t
                     AND vagrp IN vagrp_t
                     AND kokrs IN kokrs_t
                     AND strat IN strat_t
                     AND istru IN istru_t
                     AND anlzu IN anlzu_t
*                       and   aedat in aedat                 "710142
*                       and   aenam in aenam                 "710142
                     AND aennr IN aennr_t                   "N1103200
                     ORDER BY PRIMARY KEY.
* Filter according to selection-parameter PN_HIRTL
*            if pn_hirtl = 'X'.
*              if plko-xhiertl ne 'X'.
*                continue.
*              endif.
*            else.
*              if plko-xhiertl eq 'X'.
*                continue.
*              endif.
*            endif.
          PERFORM append_object_tab_eapl.
        ENDSELECT.
        "{ End ENHO AD_MEB_TASK_LISTS_RIPLKO10 IS-AD AD_MEB_TASK_LISTS }


      ENDIF.
    ENDIF.
*   endselect.
  ENDIF.
  PERFORM delete_invalid_plko_l.
  PERFORM authority-check_l.
  PERFORM fill_object_tab_l.
  REFRESH plko_tmp.
*--- Defaultsortiertung wenn nichts über SALV eingestellt -----------
  SORT object_tab1 BY plnnr plnal.

  REFRESH: gcol_listaout,gcol_trfout.

  IF object_tab1 IS NOT INITIAL.
    APPEND LINES OF object_tab1 TO  gcol_listaout.
    LOOP AT gcol_listaout INTO  lstr_listaout.
      CLEAR lstr_trfout.

      lstr_trfout-selected2 =  lstr_listaout-selected2 .
      lstr_trfout-linecheck_symbol = lstr_listaout-linecheck_symbol.
      lstr_trfout-linecheck_icon = lstr_listaout-linecheck_icon.
      lstr_trfout-selected = lstr_listaout-selected.
      lstr_trfout-plnty = lstr_listaout-plnty.
      lstr_trfout-plnal = lstr_listaout-plnal.
      lstr_trfout-plnnr = lstr_listaout-plnnr.
      lstr_trfout-ktext = lstr_listaout-ktext.
      lstr_trfout-strat = lstr_listaout-strat.
      lstr_trfout-verwe = lstr_listaout-verwe.
      lstr_trfout-statu = lstr_listaout-statu.
      lstr_trfout-werks = lstr_listaout-werks.
      lstr_trfout-arbpl = lstr_listaout-arbpl.
      lstr_trfout-istru = lstr_listaout-istru.
      lstr_trfout-equnr = lstr_listaout-equnr.
      lstr_trfout-tplnr = lstr_listaout-tplnr.
      SELECT * INTO @DATA(t_plas)
        FROM plas
        WHERE plnty = @lstr_listaout-plnty
          AND plnnr = @lstr_listaout-plnnr
          AND plnal = @lstr_listaout-plnal.

*** Begin - 31.07.2025 15:44:17 - ABAPF9AU - S4DK9A12WL	S 7000136657: INC3157503 - YSPM_TEXTOS
        IF delkz_t-low IS INITIAL.
          IF t_plas-loekz = 'X'.
            CONTINUE.
          ENDIF.
        ELSE.
          IF t_plas-loekz NE 'X'.
            CONTINUE.
          ENDIF.
        ENDIF.
*** End - 31.07.2025 15:44:20 - ABAPF9AU - S4DK9A12WL	S 7000136657: INC3157503 - YSPM_TEXTOS

        SELECT plnkn , zaehl , vornr , sumnr , arbid , werks , steus , ltxa1 , tplnr, equnr, arbei , arbeh ,
         anzzl , dauno , daune
          INTO ( @lstr_trfout-plnkn,
                 @lstr_trfout-zaehl,
                 @lstr_trfout-vornr,
                 @lstr_trfout-sumnr,
                 @lstr_trfout-arbid,
                 @lstr_trfout-werks_c,
                 @lstr_trfout-steus,
                 @lstr_trfout-ltxa1,
*                Início - S 8000013758: S4-Squad de Manutenção - UAT - XX59 - Adilson Rocha - 09/06/2022
                 @lstr_trfout-tplnr_oper,
                 @lstr_trfout-equnr_oper,
*                Fim... - S 8000013758: S4-Squad de Manutenção - UAT - XX59 - Adilson Rocha - 09/06/2022
                 @lstr_trfout-arbei,
                 @lstr_trfout-arbeh,
                 @lstr_trfout-anzzl,
                 @lstr_trfout-dauno,
                 @lstr_trfout-daune )
           FROM plpo
           WHERE plnty = @t_plas-plnty
             AND plnnr = @t_plas-plnnr
             AND plnkn = @t_plas-plnkn
*             and zaehl = @t_plas-zaehl
             AND loekz = ' '.
          CLEAR texto.
          texto-mandt = sy-mandt.
          texto-plnty = t_plas-plnty.
          texto-plnnr = t_plas-plnnr.
          texto-plnkn = t_plas-plnkn.
          texto-zaehl = t_plas-zaehl.
          v_name_trf   = texto." separated by space.

          CALL FUNCTION 'READ_TEXT'
            EXPORTING
              id                      = 'PLPO'
              language                = sy-langu
              name                    = v_name_trf
              object                  = 'ROUTING'
            TABLES
              lines                   = ti_lines
            EXCEPTIONS
              id                      = 1
              language                = 2
              name                    = 3
              not_found               = 4
              object                  = 5
              reference_check         = 6
              wrong_access_to_archive = 7
              OTHERS                  = 8.

          IF sy-subrc <> 0.
            CLEAR lstr_trfout-char01.
          ELSE.
            lstr_trfout-char01 = 'X'.
          ENDIF.
          CALL FUNCTION 'CR_WORKSTATION_READ'
            EXPORTING
              id        = lstr_trfout-arbid
              msgty     = 'S'
            IMPORTING
              arbpl     = lstr_trfout-arbpl
              werks     = object_tab1-awerk          "N1672178
            EXCEPTIONS
              not_found = 01.
          IF NOT sy-subrc IS INITIAL.
            CLEAR lstr_trfout-arbpl.
          ENDIF.
          CLEAR lstr_trfout-uvorn.
          APPEND lstr_trfout TO  gcol_trfout.
          DATA: l_vornr TYPE vornr.
          l_vornr = lstr_trfout-vornr.
          SELECT plnkn , zaehl , vornr , sumnr , arbid , werks , steus , ltxa1 , tplnr, equnr, arbei , arbeh ,
                 anzzl , dauno , daune, vornr
             INTO ( @lstr_trfout-plnkn,
                    @lstr_trfout-zaehl,
                    @lstr_trfout-uvorn,
                    @lstr_trfout-sumnr,
                    @lstr_trfout-arbid,
                    @lstr_trfout-werks_c,
                    @lstr_trfout-steus,
                    @lstr_trfout-ltxa1,
*                   Início - S 8000013758: S4-Squad de Manutenção - UAT - XX59 - Adilson Rocha - 09/06/2022
                    @lstr_trfout-tplnr_oper,
                    @lstr_trfout-equnr_oper,
*                   Fim... - S 8000013758: S4-Squad de Manutenção - UAT - XX59 - Adilson Rocha - 09/06/2022
                    @lstr_trfout-arbei,
                    @lstr_trfout-arbeh,
                    @lstr_trfout-anzzl,
                    @lstr_trfout-dauno,
                    @lstr_trfout-daune,
                    @lstr_trfout-uvorn )
        FROM plpo
        WHERE plnty = @t_plas-plnty
          AND plnnr = @t_plas-plnnr
          AND sumnr = @t_plas-plnkn
          AND loekz = ' '.


            CALL FUNCTION 'CR_WORKSTATION_READ'
              EXPORTING
                id        = lstr_trfout-arbid
                msgty     = 'S'
              IMPORTING
                arbpl     = lstr_trfout-arbpl
                werks     = object_tab1-awerk          "N1672178
              EXCEPTIONS
                not_found = 01.
            IF NOT sy-subrc IS INITIAL.
              CLEAR lstr_trfout-arbpl.
            ENDIF.
            CLEAR texto.
            texto-mandt = sy-mandt.
            texto-plnty = lstr_trfout-plnty.
            texto-plnnr = lstr_trfout-plnnr.
            texto-plnkn = lstr_trfout-plnkn.
            texto-zaehl = lstr_trfout-zaehl.
            v_name_trf   = texto." separated by space.

            CALL FUNCTION 'READ_TEXT'
              EXPORTING
                id                      = 'PLPO'
                language                = sy-langu
                name                    = v_name_trf
                object                  = 'ROUTING'
              TABLES
                lines                   = ti_lines
              EXCEPTIONS
                id                      = 1
                language                = 2
                name                    = 3
                not_found               = 4
                object                  = 5
                reference_check         = 6
                wrong_access_to_archive = 7
                OTHERS                  = 8.

            IF sy-subrc <> 0.
              CLEAR lstr_trfout-char01.
            ELSE.
              lstr_trfout-char01 = 'X'.
            ENDIF.

            lstr_trfout-vornr = l_vornr. "  Operacao
            APPEND lstr_trfout TO  gcol_trfout.
            CLEAR lstr_trfout-vornr.
          ENDSELECT.
          IF sy-subrc  NE 0.
            CLEAR  l_vornr.
          ENDIF.
        ENDSELECT.
      ENDSELECT.
    ENDLOOP.
  ENDIF.
  REFRESH gcol_listaout.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  F_MARCA_PROCESSADOS_OPE
*&---------------------------------------------------------------------*
FORM f_marca_processados.

  DATA: lstr_orderout     LIKE LINE OF gcol_orderout.
  DATA: lstr_noteout      LIKE LINE OF gcol_noteout.
  DATA: lstr_medout       LIKE LINE OF gcol_medout.
  DATA: lstr_operacoesout LIKE LINE OF gcol_operacoesout.
  DATA: lstr_listaout     LIKE LINE OF gcol_listaout.

  DATA: lstr_orderbkp     LIKE LINE OF gcol_orderout.
  DATA: lstr_notebkp      LIKE LINE OF gcol_noteout.
  DATA: lstr_medbkp       LIKE LINE OF gcol_medout.
  DATA: lstr_operacoesbkp LIKE LINE OF gcol_operacoesout.
  DATA: lstr_listabkp     LIKE LINE OF gcol_listaout.

  DATA: lc_indice         TYPE sy-tabix.

  IMPORT wc_coluna FROM MEMORY ID 'PEDK9A4U7G'.

  " =============================================================================================================================================
  " Após refresh resgatar a marcação do que já foi feito de acordo com o Tipo de Filtro setado (radiobutton rb_order, rb_note ou rb_med, rb_dem)
  " =============================================================================================================================================
  " ..........................................................................
  " ORDENS ou Demandas:ORDENS sem Nota e sem Medida (dy_dor)
  " ..........................................................................
  IF ( rb_order = 'X' ). " OR ( rb_dem = 'X' AND dy_dor = 'X' ).                " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    CASE wc_coluna .
      WHEN 'AUFNR'.
        SORT gcol_orderout BY aufnr.
        SORT gcol_orderbkp BY aufnr.

        LOOP AT gcol_orderout INTO lstr_orderout.
          lc_indice = sy-tabix.
          CLEAR: lstr_orderbkp.
          READ TABLE gcol_orderbkp INTO lstr_orderbkp WITH KEY aufnr = lstr_orderout-aufnr BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_orderout INDEX lc_indice FROM lstr_orderbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.

      WHEN 'QMNUM'.
        SORT gcol_noteout BY qmnum.
        SORT gcol_notebkp BY qmnum.

        LOOP AT gcol_orderout INTO lstr_orderout.
          lc_indice = sy-tabix.
          CLEAR: lstr_orderbkp.
          READ TABLE gcol_orderbkp INTO lstr_orderbkp WITH KEY qmnum = lstr_orderout-qmnum BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_orderout INDEX lc_indice FROM lstr_orderbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.

    ENDCASE.

    " ..........................................................................
    " NOTAS ou Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)
    " ..........................................................................
  ELSEIF ( rb_note = 'X' ). " OR ( rb_dem = 'X' AND dy_dnt = 'X' ).             " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    CASE wc_coluna .
      WHEN 'AUFNR'.
        SORT gcol_noteout BY aufnr.
        SORT gcol_notebkp BY aufnr.

        LOOP AT gcol_noteout INTO lstr_noteout.
          lc_indice = sy-tabix.
          CLEAR: lstr_notebkp.
          READ TABLE gcol_notebkp INTO lstr_notebkp WITH KEY aufnr = lstr_noteout-aufnr BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_noteout INDEX lc_indice FROM lstr_notebkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.

      WHEN 'QMNUM'.
        SORT gcol_noteout BY qmnum.
        SORT gcol_notebkp BY qmnum.

        LOOP AT gcol_noteout INTO lstr_noteout.
          lc_indice = sy-tabix.
          CLEAR: lstr_notebkp.
          READ TABLE gcol_notebkp INTO lstr_notebkp WITH KEY qmnum = lstr_noteout-qmnum BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_noteout INDEX lc_indice FROM lstr_notebkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.
    ENDCASE.

    " ..........................................................................
    " MEDIDAS ou Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
    " ..........................................................................
  ELSEIF ( rb_med = 'X'). " OR ( rb_dem = 'X' AND dy_dme = 'X' ).               " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    CASE wc_coluna .
      WHEN 'AUFNR'.
        " SORT realizado para garantir funcionamento do BINARY SEARCH
        " Teoricamente não seria necessário realizar novamente este SORT
        " IMPORTANTE: Futuramente realizar refatoração dessa forma de atualizar os indicadores de seleção, símbolo e icone similar a transações como IW38
        SORT gcol_medout BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.
        SORT gcol_medbkp BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.

        LOOP AT gcol_medout INTO lstr_medout.
          lc_indice = sy-tabix.
          CLEAR: lstr_medbkp.
          READ TABLE gcol_medbkp INTO lstr_medbkp WITH KEY qmnum    = lstr_medout-qmnum
                                                           m_qsmnum = lstr_medout-m_qsmnum
                                                           m_manum  = lstr_medout-m_manum
                                                           a_qmanum = lstr_medout-a_qmanum
                                                           a_manum  = lstr_medout-a_manum  BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_medout INDEX lc_indice FROM lstr_medbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.

      WHEN 'QMNUM'.
        " SORT realizado para garantir funcionamento do BINARY SEARCH
        " Teoricamente não seria necessário realizar novamente este SORT
        " IMPORTANTE: Futuramente realizar refatoração dessa forma de atualizar os indicadores de seleção, símbolo e icone similar a transações como IW38
        SORT gcol_medout BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.
        SORT gcol_medbkp BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.

        LOOP AT gcol_medout INTO lstr_medout.
          lc_indice = sy-tabix.
          CLEAR: lstr_medbkp.
          READ TABLE gcol_medbkp INTO lstr_medbkp WITH KEY qmnum    = lstr_medout-qmnum
                                                           m_qsmnum = lstr_medout-m_qsmnum
                                                           m_manum  = lstr_medout-m_manum
                                                           a_qmanum = lstr_medout-a_qmanum
                                                           a_manum  = lstr_medout-a_manum  BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_medout INDEX lc_indice FROM lstr_medbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.

      WHEN 'M_QSMNUM'.
        " SORT realizado para garantir funcionamento do BINARY SEARCH
        " Teoricamente não seria necessário realizar novamente este SORT
        " IMPORTANTE: Futuramente realizar refatoração dessa forma de atualizar os indicadores de seleção, símbolo e icone similar a transações como IW38
        SORT gcol_medout BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.
        SORT gcol_medbkp BY qmnum m_qsmnum m_manum a_qmanum a_manum qurnum urnum.

        LOOP AT gcol_medout INTO lstr_medout.
          lc_indice = sy-tabix.
          CLEAR: lstr_medbkp.
          READ TABLE gcol_medbkp INTO lstr_medbkp WITH KEY qmnum    = lstr_medout-qmnum
                                                           m_qsmnum = lstr_medout-m_qsmnum
                                                           m_manum  = lstr_medout-m_manum
                                                           a_qmanum = lstr_medout-a_qmanum
                                                           a_manum  = lstr_medout-a_manum  BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_medout INDEX lc_indice FROM lstr_medbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.
    ENDCASE.

    " ..........................................................................
    " OPERAÇÕES
    " ..........................................................................
  ELSEIF rb_ope = 'X'.
    CASE wc_coluna.
      WHEN 'AUFNR'.
        SORT gcol_operacoesbkp BY aufnr vornr.
        SORT gcol_operacoesout BY aufnr vornr.

        LOOP AT gcol_operacoesout INTO lstr_operacoesout.
          lc_indice = sy-tabix.
          CLEAR: lstr_operacoesbkp.
          READ TABLE gcol_operacoesbkp INTO lstr_operacoesbkp WITH KEY aufnr = lstr_operacoesout-aufnr
                                                                       vornr = lstr_operacoesout-vornr
                                                                       BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_operacoesout INDEX lc_indice FROM lstr_operacoesbkp TRANSPORTING selected linecheck_symbol linecheck_icon.
          ENDIF.
        ENDLOOP.

      WHEN 'QMNUM'.
        SORT gcol_operacoesbkp BY aufnr qmnum vornr.
        SORT gcol_operacoesout BY aufnr qmnum vornr.

        LOOP AT gcol_operacoesout INTO lstr_operacoesout WHERE qmnum NE space.
          lc_indice = sy-tabix.
          CLEAR: lstr_operacoesbkp.
          READ TABLE gcol_operacoesbkp INTO lstr_operacoesbkp WITH KEY aufnr = lstr_operacoesout-aufnr
                                                                       qmnum = lstr_operacoesout-qmnum
                                                                       vornr = lstr_operacoesout-vornr
                                                                       BINARY SEARCH. "7000059731
          IF sy-subrc = 0.
            MODIFY gcol_operacoesout INDEX lc_indice FROM lstr_operacoesbkp TRANSPORTING selected linecheck_symbol linecheck_icon .
          ENDIF.
        ENDLOOP.
    ENDCASE.
  ELSEIF rb_lis = 'X'.

  ELSEIF rb_trf = 'X'.
  ENDIF.

ENDFORM.                    " F_MARCA_PROCESSADOS_OPE
*&---------------------------------------------------------------------*
*&      Form  F_GET_SELECTED_ROWS
*&---------------------------------------------------------------------*
FORM f_get_selected_rows USING p_i_ucomm TYPE syucomm.

  DATA:
* Internal table for indexes of selected rows
    gi_index_rows  TYPE lvc_t_row,
* Information about 1 row
    g_selected_row LIKE lvc_s_row,
* l_lines
    l_lines        TYPE i.

  DATA: lstr_orderout     LIKE LINE OF gcol_orderout.
  DATA: lstr_noteout      LIKE LINE OF gcol_noteout.
  DATA: lstr_medout       LIKE LINE OF gcol_medout.
  DATA: lstr_operacoesout LIKE LINE OF gcol_operacoesout.
  DATA: lstr_listaout     LIKE LINE OF object_tab1.
  DATA: lstr_trfout       LIKE LINE OF object_tab2.
  IF gr_grid IS  NOT INITIAL. " ABAPMFP3 - 18.12.2019
    CALL METHOD gr_grid->get_selected_rows
      IMPORTING
        et_index_rows = gi_index_rows.
  ELSE.
    gi_index_rows = gt_selected_rows.
  ENDIF.

  DESCRIBE TABLE gi_index_rows LINES l_lines.
  IF l_lines <> 0.

** INÍCIO - 23.08.2021 17:33:00 - ABAPD94R
    IF gv_doc = 'X'.

      LOOP AT gt_data ASSIGNING FIELD-SYMBOL(<fs_data>) WHERE selected = 'X'.
        <fs_data>-selected = abap_false.
      ENDLOOP.

      LOOP AT gi_index_rows INTO g_selected_row.        "#EC CI_NOORDER
        READ TABLE gt_data INTO DATA(ls_data) INDEX g_selected_row-index.
        IF sy-subrc = 0.

          ls_data-selected         = 'X'. "selected
          ls_data-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              ls_data-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gt_data INDEX g_selected_row-index FROM ls_data
          TRANSPORTING selected linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.
** FIM - 23.08.2021 17:33:00 - ABAPD94R

      " ..........................................................................
      " ORDENS ou Demandas:ORDENS sem Nota e sem Medida (dy_dor)
      " ..........................................................................
** INÍCIO - 23.08.2021 17:33:17 - ABAPD94R
*    IF ( rb_order = 'X' ). " OR ( rb_dem = 'X' AND dy_dor = 'X' ).                " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
    ELSEIF ( rb_order = 'X' ). " OR ( rb_dem = 'X' AND dy_dor = 'X' ).                " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
** FIM - 23.08.2021 17:33:17 - ABAPD94R
      LOOP AT gi_index_rows INTO g_selected_row.        "#EC CI_NOORDER
        READ TABLE gcol_orderout INTO lstr_orderout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_orderout-selected         = 'X'. "selected
          lstr_orderout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_orderout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_orderout INDEX g_selected_row-index FROM lstr_orderout
          TRANSPORTING selected linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.

      " ..........................................................................
      " NOTAS ou Demandas:NOTAS sem Medida e sem Ordem (dy_dnt)
      " ..........................................................................
    ELSEIF ( rb_note = 'X' ). " OR ( rb_dem = 'X' AND dy_dnt = 'X' ).             " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
      LOOP AT gi_index_rows INTO g_selected_row.        "#EC CI_NOORDER
        READ TABLE gcol_noteout INTO lstr_noteout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_noteout-selected         = 'X'. "selected
          lstr_noteout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_noteout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.
          MODIFY gcol_noteout INDEX g_selected_row-index FROM lstr_noteout "#EC CI_NOORDER
          TRANSPORTING selected linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.

      " ..........................................................................
      " MEDIDAS ou Demandas:NOTAS E MEDIDAS com Ordem associada (dy_dme)
      " ..........................................................................
    ELSEIF ( rb_med = 'X'). " OR ( rb_dem = 'X' AND dy_dme = 'X' ).               " ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO e FIM ###
      LOOP AT gi_index_rows INTO g_selected_row.
        READ TABLE gcol_medout INTO lstr_medout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_medout-selected         = 'X'. "selected
          lstr_medout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_medout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_medout INDEX g_selected_row-index FROM lstr_medout
          TRANSPORTING selected linecheck_symbol linecheck_icon .
        ENDIF.
      ENDLOOP.

      " ..........................................................................
      " OPERAÇÕES
      " ..........................................................................
    ELSEIF rb_ope = 'X'.
      LOOP AT gi_index_rows INTO g_selected_row.
        READ TABLE gcol_operacoesout INTO lstr_operacoesout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_operacoesout-selected         = 'X'. "selected
          lstr_operacoesout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_operacoesout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_operacoesout INDEX g_selected_row-index FROM lstr_operacoesout
          TRANSPORTING selected linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.
** INÍCIO - 11.08.2021 16:48:48 - ABAPD94R
    ELSEIF rb_con = 'X'.

      LOOP AT gcol_confirmacaoout ASSIGNING FIELD-SYMBOL(<fs_conf>) WHERE selected2 = 'X'.
        <fs_conf>-selected2 = abap_false.
      ENDLOOP.

      LOOP AT gi_index_rows INTO g_selected_row.        "#EC CI_NOORDER
        READ TABLE gcol_confirmacaoout INTO DATA(lstr_confirmacaoout) INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_confirmacaoout-selected2        = 'X'. "selected
          lstr_confirmacaoout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_confirmacaoout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_confirmacaoout INDEX g_selected_row-index FROM lstr_confirmacaoout
          TRANSPORTING selected2 linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.
** FIM - 11.08.2021 16:48:48 - ABAPD94R
    ELSEIF rb_lis = 'X'.
      LOOP AT gcol_listaout ASSIGNING FIELD-SYMBOL(<fs_lista>) WHERE selected2 = 'X'.
        <fs_lista>-selected2 = abap_false.
      ENDLOOP.

      LOOP AT gi_index_rows INTO g_selected_row.
        READ TABLE gcol_listaout INTO lstr_listaout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_listaout-selected         = 'X'. "selected
*          lstr_listaout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_listaout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_listaout INDEX g_selected_row-index FROM lstr_listaout
          TRANSPORTING selected  linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.
    ELSEIF rb_trf EQ 'X'.
      LOOP AT gcol_trfout ASSIGNING FIELD-SYMBOL(<fs_trf>) WHERE selected2 = 'X'.
        <fs_trf>-selected2 = abap_false.
      ENDLOOP.

      LOOP AT gi_index_rows INTO g_selected_row.        "#EC CI_NOORDER
        READ TABLE gcol_trfout INTO lstr_trfout INDEX g_selected_row-index.
        IF sy-subrc = 0.

          lstr_trfout-selected         = 'X'. "selected
*          lstr_listaout-linecheck_symbol = sym_check_mark. " sym_printer

          CASE p_i_ucomm.
            WHEN '&EXCEL'.
              lstr_trfout-linecheck_icon = icon_xxl.
            WHEN OTHERS.
          ENDCASE.

          MODIFY gcol_trfout INDEX g_selected_row-index FROM lstr_trfout
          TRANSPORTING selected  linecheck_symbol linecheck_icon . "#EC CI_NOORDER
        ENDIF.
      ENDLOOP.

    ENDIF.
  ENDIF.

  gcol_orderbkp[]     = gcol_orderout[].
  gcol_notebkp[]      = gcol_noteout[].
  gcol_medbkp[]       = gcol_medout[].
  gcol_operacoesbkp[] = gcol_operacoesout[].
** INÍCIO - 16.08.2021 09:50:17 - ABAPD94R
  gcol_confirmacaobkp[] = gcol_confirmacaoout[].
** FIM - 16.08.2021 09:50:17 - ABAPD94R
  gcol_databkp[] = gt_data[].
  gcol_listabkp[] =  gcol_listaout[].
  gcol_trfbkp[] = gcol_trfout[].
ENDFORM.                    " F_GET_SELECTED_ROWS
*&---------------------------------------------------------------------*
*&      Form  F_RUN_BACKGROUND_WSHEET
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM f_run_background_wsheet.

  DESCRIBE TABLE gcol_medout LINES DATA(li_lines).
** INÍCIO - 16.08.2021 10:41:44 - ABAPD94R


** FIM - 16.08.2021 10:41:44 - ABAPD94R
  IF gcol_orderout IS NOT INITIAL.
    DESCRIBE TABLE gcol_orderout LINES li_lines.
  ENDIF.
  IF gcol_noteout IS NOT INITIAL.
    DESCRIBE TABLE gcol_noteout LINES li_lines.
  ENDIF.
  IF gcol_operacoesout IS NOT INITIAL.
    DESCRIBE TABLE gcol_operacoesout LINES li_lines.
  ENDIF.
  IF gcol_confirmacaoout IS NOT INITIAL.
    DESCRIBE TABLE gcol_confirmacaoout LINES li_lines.
  ENDIF.
** INÍCIO - 25.08.2021 09:19:55 - ABAPD94R
  IF gt_data IS NOT INITIAL.
    DESCRIBE TABLE gt_data LINES li_lines.
  ENDIF.
** FIM - 25.08.2021 09:19:55 - ABAPD94R
  IF gcol_listaout IS NOT INITIAL.
    DESCRIBE TABLE gcol_listaout LINES li_lines.
  ENDIF.
  IF gcol_trfout IS NOT INITIAL.
    DESCRIBE TABLE gcol_trfout LINES li_lines.
  ENDIF.

  DO li_lines TIMES.
    APPEND INITIAL LINE TO gt_selected_rows ASSIGNING FIELD-SYMBOL(<fs_s_row>).
    <fs_s_row>-index = sy-index.
  ENDDO.
                                                        "#EC CI_NOORDER
  PERFORM f_get_selected_rows USING '&EXCEL'.           "#EC CI_NOORDER
  PERFORM cria_planilha.

  IF gr_grid IS INITIAL.
    IF cl_gui_alv_grid=>offline( ) IS INITIAL.

      " Cria o container da ALVGrid
      CREATE OBJECT gr_container
        EXPORTING
          container_name = 'CC_CONTAINER1'.

      " Cria objeto ALVGrid associado ao container
      CREATE OBJECT gr_grid
        EXPORTING
          i_parent = gr_container.
    ELSE.
      CREATE OBJECT gr_grid
        EXPORTING
          i_parent = g_dock.
    ENDIF.
  ENDIF.

  " Monta o fieldcatalog para a ITable de log de execução a ser impressa/apresentada no spool do cenário de exportação VIA EXECUÇÃO BACKGROUND e POR PLANILHA
  DATA lstr_fieldcat LIKE LINE OF git_fieldcat.
  CLEAR: git_fieldcat[].
  CLEAR lstr_fieldcat.
  ADD 1 TO lstr_fieldcat-col_pos.
  lstr_fieldcat-fieldname     = 'NUMBER'.
  lstr_fieldcat-ref_field     = 'NUMBER'.
  lstr_fieldcat-ref_table     = 'BAPIRET2'.
*  lstr_fieldcat-coltext       = text-525.
*  lstr_fieldcat-seltext       = text-525.
  lstr_fieldcat-fix_column    = 'X'.
  lstr_fieldcat-just          = 'R'.
  lstr_fieldcat-outputlen     = '3'.
  APPEND lstr_fieldcat TO git_fieldcat.

  CLEAR lstr_fieldcat.
  ADD 1 TO lstr_fieldcat-col_pos.
  lstr_fieldcat-fieldname     = 'MESSAGE'.
  lstr_fieldcat-ref_field     = 'MESSAGE'.
  lstr_fieldcat-ref_table     = 'BAPIRET2'.
*  lstr_fieldcat-coltext       = text-525.
*  lstr_fieldcat-seltext       = text-525.
  lstr_fieldcat-fix_column    = 'X'.
  lstr_fieldcat-just          = 'R'.
  lstr_fieldcat-outputlen     = '150'.
  APPEND lstr_fieldcat TO git_fieldcat.

  " Apresenta as informações na ITable de log de execução no spool para o cenário de exportação VIA EXECUÇÃO BACKGROUND e POR PLANILHA
  gr_grid->set_table_for_first_display(     ##SUBRC_OK
    CHANGING
        it_outtab                     = gt_export_bkg_wsheet_log[]
        it_fieldcatalog               = git_fieldcat[]
    EXCEPTIONS
      invalid_parameter_combination = 1
      program_error                 = 2
      too_many_lines                = 3
      OTHERS                        = 4 ) .

ENDFORM.
" ### REMOÇÃO tipo DEMANDAS (rb_dem) - INÍCIO ###
*&---------------------------------------------------------------------*
*&      Form  BUSCA_TEXTO_ITEM_CAUSA
*&---------------------------------------------------------------------*
*form busca_texto_item_causa  using    p_lstr_note type ty_note
*                             changing p_txtcdfe   type riwo00-txtcdfe
*                                      p_txtcdot   type riwo00-txtcdot
*                                      p_txtcdur   type riwo00-txtcdur.
*  data: e_notifheader_export type bapi2080_nothdre,
*        e_notifhdtext        type bapi2080_nothdtxte,
*        ti_notiflongtxt      type table of bapi2080_notfulltxte,
*        ti_notifitem         type table of bapi2080_notiteme,
*        ti_notifcaus         type table of bapi2080_notcause,
*        ti_notifactv         type table of bapi2080_notactve,
*        ti_notiftask         type table of bapi2080_nottaske,
*        ti_notifpartnr       type table of bapi2080_notpartnre,
*        ti_return            type table of bapiret2.
*
*  data: wa_notiflongtxt type bapi2080_notfulltxte,
*        wa_notifitem    type bapi2080_notiteme,
*        wa_notifcaus    type bapi2080_notcause,
*        wa_notifactv    type bapi2080_notactve,
*        wa_notiftask    type bapi2080_nottaske,
*        wa_notifpartnr  type bapi2080_notpartnre,
*        wa_return       type bapiret2.
*
*  if lc_qmnum ne p_lstr_note-qmnum.
*    clear: e_notifheader_export, e_notifhdtext.
*    refresh: ti_notiflongtxt, ti_notifitem, ti_notifcaus,
*             ti_notifactv,    ti_notiftask, ti_notifpartnr,
*             ti_return.
*
*
*    call function 'BAPI_ALM_NOTIF_GET_DETAIL'
*      exporting
*        number             = p_lstr_note-qmnum
*      importing
*        notifheader_export = e_notifheader_export
*        notifhdtext        = e_notifhdtext
*      tables
*        notlongtxt         = ti_notiflongtxt
*        notitem            = ti_notifitem
*        notifcaus          = ti_notifcaus
*        notifactv          = ti_notifactv
*        notiftask          = ti_notiftask
*        notifpartnr        = ti_notifpartnr
*        return             = ti_return.
*
*    lc_qmnum = p_lstr_note-qmnum.
*  endif.
*
*
*  sort ti_notifitem by notif_no item_key.
*  read table ti_notifitem into wa_notifitem  with key notif_no = p_lstr_note-qmnum
*                                                      item_key = p_lstr_note-fenum binary search. "7000059731
*  if sy-subrc = 0.
*    p_txtcdot = wa_notifitem-txt_objptcd. "Descrição Parte do objeto
*    p_txtcdfe = wa_notifitem-txt_probcd.  "Descrição Código do problema ou do dano
*  else.
*    clear: p_txtcdfe, p_txtcdot.
*  endif.
*
*  sort ti_notifcaus by notif_no item_key cause_key.
*  read table ti_notifcaus into wa_notifcaus with key notif_no = p_lstr_note-qmnum
*                                                     item_key = p_lstr_note-fenum
*                                                    cause_key = p_lstr_note-urnum binary search. "7000059731
*  if sy-subrc = 0.
*    p_txtcdur = wa_notifcaus-txt_causecd. "Descrição Parte do objeto
*  else.
*    clear: p_txtcdur.
*  endif.
*
*endform.                    " BUSCA_TEXTO_ITEM_CAUSA
" ### REMOÇÃO tipo DEMANDAS (rb_dem) - FIM ###
*&---------------------------------------------------------------------*
*& Form f_sscrgetdata_con
*&---------------------------------------------------------------------*
*& text
*&---------------------------------------------------------------------*
*& -->  p1        text
*& <--  p2        text
*&---------------------------------------------------------------------*
FORM f_sscrgetdata_con .
  RANGES: r_iphas FOR viauf_afvc-iphas.  " status order
  RANGES: gr_stzhl FOR afru-stzhl,
          gr_stokz FOR afru-stokz.
  DATA: ti_lines   LIKE tline OCCURS 0 WITH HEADER LINE,
        v_name_con LIKE thead-tdname.

  IF NOT dy_iar_c IS INITIAL.
    CLEAR r_iphas.
    r_iphas-option = 'EQ'.
    r_iphas-sign = 'I'.
    r_iphas-low = '2'.
    APPEND r_iphas.
  ENDIF.

  IF NOT dy_abg IS INITIAL.
    CLEAR r_iphas.
* technically completet
    r_iphas-option = 'EQ'.
    r_iphas-sign = 'I'.
    r_iphas-low = '3'.
    APPEND r_iphas.
* deletion flag
    r_iphas-low = '4'.
    APPEND r_iphas.
* completed
    r_iphas-low = '6'.
    APPEND r_iphas.
  ENDIF.

  IF NOT no_canc IS INITIAL.
    gr_stzhl-sign   = 'I'.
    gr_stzhl-option = 'EQ'.
    gr_stzhl-low    = '00000000'.
    APPEND gr_stzhl.
    gr_stokz-sign   = 'I'.
    gr_stokz-option = 'EQ'.
    gr_stokz-low    = ' '.
    APPEND gr_stokz.
  ENDIF.

  PERFORM get_arbid TABLES arbid_tab_o arbpl_oc werks_oc arbid_o.
  PERFORM get_arbid TABLES arbid_tab_c arbpl_c werks_c arbid_c.

  SELECT t0~mandt t0~rueck t0~rmzhl t0~ersda t0~ernam t0~laeda t0~aenam t0~budat t1~ingpr  t0~ltxa1
         t0~abarb t0~ismnw t0~ismne t0~learr t0~idaur t0~idaue t0~pernr t0~isdd t0~isdz t0~iedd
         t0~iedz t0~pedd t0~pedz t0~aueru  t0~ausor t0~stndr t1~auart t0~aufnr t0~vornr t0~ofmnw
         t0~ofmne t0~leknw t0~odaur t0~odaue t0~stokz t0~stzhl t0~extid t0~werks AS werki t2~arbpl AS iarbpl "2182396
         t3~arbpl AS parbpl t0~loart  t1~arbei t1~arbeh  t1~larnt t1~tplnr t1~equnr t1~werks AS pwerk
         t0~grund  t0~txtsp t1~iwerk t0~bemot t1~uii t1~objnr t1~sumnr t1~aufpl t0~ismnu t0~ofmnu
         t4~vornr AS svorn
INTO CORRESPONDING FIELDS OF TABLE join_result_table
FROM ( ( ( ( afru AS t0 INNER JOIN viauf_afvc AS t1 ON t0~rueck = t1~rueck
      AND t0~aufnr = t1~aufnr AND t0~mandt = t1~mandt )
   LEFT OUTER JOIN afvc AS t4 ON t4~aufpl = t1~aufpl AND t4~aplzl = t1~sumnr AND t4~mandt = t1~mandt )
   INNER JOIN crhd AS t2 ON t0~arbid = t2~objid AND t0~mandt = t2~mandt )
   LEFT OUTER JOIN crhd AS t3 ON t1~arbid = t3~objid AND t1~mandt = t3~mandt )
   WHERE t1~iphas IN r_iphas
    AND t1~aufnr IN aufnr_oc
    AND t1~auart IN auart_oc
    AND t1~equnr IN equnr_oc
    AND t1~tplnr IN strno_o
    AND t1~arbid IN arbid_o
    AND t1~werks IN werks_oc
    AND t1~larnt IN larnt_o
    AND t1~rueck IN rueck_c
*       AND t1~uii   IN gr_uii
    AND t0~pernr IN pernr_c
    AND t0~ersda IN ersda_c
    AND t0~ernam IN ernam_c
    AND t0~budat IN budat_c
    AND t0~werks IN werks_c
    AND t0~arbid IN arbid_c
    AND t0~aueru IN aueru_c
    AND t0~grund IN grund_c
    AND t0~loart IN loart_c
    AND t0~learr IN learr_c
    AND t0~isdd IN isdd_c
    AND t0~isdz IN isdz_c
    AND t0~iedd IN iedd_c
    AND t0~iedz IN iedz_c
    AND t0~stzhl IN gr_stzhl
  AND t0~stokz IN gr_stokz.

  IF sy-subrc IS INITIAL.
    PERFORM complete_object_tab.
    gcol_confirmacaoout[] = object_tab[].

    LOOP AT gcol_confirmacaoout ASSIGNING FIELD-SYMBOL(<fs_confirmacao>).

      CONCATENATE sy-mandt <fs_confirmacao>-rueck <fs_confirmacao>-rmzhl INTO v_name_con.

      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          id                      = 'RMEL'
          language                = sy-langu
          name                    = v_name_con
          object                  = 'AUFK'
        TABLES
          lines                   = ti_lines
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.

      IF sy-subrc IS INITIAL.
        MOVE 'X' TO <fs_confirmacao>-char01.
      ENDIF.

    ENDLOOP.
  ENDIF.
ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  GET_ARBID
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->ARBPL                                                        *
*      -->WERK                                                         *
*      -->ARBID_TAB                                                    *
*      -->ARBID                                                        *
*----------------------------------------------------------------------*
FORM get_arbid TABLES arbid_tab STRUCTURE arbid_tab_o
                      arbpl STRUCTURE arbpl_o
                      werks STRUCTURE werks_o
                      arbid STRUCTURE arbid_o.
* read internal number of a work center -------------------------------*
  DESCRIBE TABLE arbpl LINES sy-tabix.
  IF NOT sy-tabix IS INITIAL.
    SELECT objid arbpl FROM crhd INTO TABLE arbid_tab
      WHERE arbpl IN arbpl
    AND werks IN werks.
*-- no work center found ----------------------------------------------*
    DESCRIBE TABLE arbid_tab LINES sy-tabix.
    IF sy-tabix IS INITIAL.
      MESSAGE s047(ih).
      STOP.
    ENDIF.
*-- too many work centers for select-----------------------------------*
    IF sy-tabix > 255.
      MESSAGE i103(ih).
      STOP.
    ENDIF.
*-- fill range for selection ------------------------------------------*
    arbid-option = 'EQ'.
    arbid-sign = 'I'.
    LOOP AT arbid_tab.
      arbid-low = arbid_tab-arbid.
      APPEND arbid.
    ENDLOOP.
    SORT arbid_tab.
  ENDIF.
ENDFORM.                               " GET_ARBID
*&---------------------------------------------------------------------*
*&      Form  COMPLETE_OBJECT_TAB
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM complete_object_tab .

  DATA: idx          TYPE i,
        wa           LIKE object_tab,
        l_vornr      LIKE afvc-vornr,
        lv_not_valid TYPE abap_bool,
        ls_conf      TYPE afru.
  DATA: sttxt LIKE rihafvr-sttxt,      " system status
        ustxt LIKE rihafvr-ustxt.      " user status

  FIELD-SYMBOLS <fs> LIKE join_result.
  LOOP AT join_result_table ASSIGNING <fs>.

    IF sy-batch IS INITIAL.
      MOVE-CORRESPONDING <fs> TO ls_conf.
      PERFORM convert_output_to_timezone_f87 CHANGING ls_conf
                                                      lv_not_valid.
      MOVE-CORRESPONDING ls_conf TO <fs>.
    ENDIF.

    IF strno_o[] IS INITIAL.
      <fs>-tplnr_int = <fs>-tplnr.
    ENDIF.

    IF NOT <fs>-stzhl IS INITIAL.
      <fs>-idaur = ( -1 ) * <fs>-idaur.
      <fs>-odaur = ( -1 ) * <fs>-odaur.
      <fs>-ofmnw = ( -1 ) * <fs>-ofmnw.
      <fs>-ismnw = ( -1 ) * <fs>-ismnw.
    ENDIF.
    CLEAR object_tab.

    MOVE-CORRESPONDING <fs> TO object_tab.

* populate status
    PERFORM get_status USING <fs>-objnr.

* sub-operation ?
    IF NOT <fs>-sumnr IS INITIAL.
      object_tab-uvorn = <fs>-vornr.
      object_tab-vornr = <fs>-svorn.
    ELSE.
      CLEAR object_tab-uvorn.
    ENDIF.

* name of employee and personal area
    IF NOT object_tab-pernr IS INITIAL.

      CALL FUNCTION 'WFD_RP_CHECK_PERNR'
        EXPORTING
          beg               = sy-datum
          pnr               = object_tab-pernr
        IMPORTING
          name              = object_tab-name
          persa             = object_tab-persa
        EXCEPTIONS
          data_fault        = 1
          person_not_active = 2
          person_unknown    = 3
          exit_fault        = 4
          pernr_missing     = 5
          date_missing      = 6
          OTHERS            = 7.
    ENDIF.

    IF NOT <fs>-ismnu IS INITIAL AND
       <fs>-ismne NE <fs>-ismnu.
      CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
        EXPORTING
          input    = <fs>-ismnw
          unit_in  = <fs>-ismne
          unit_out = <fs>-ismnu
        IMPORTING
          output   = object_tab-ismnw.
      object_tab-ismne = <fs>-ismnu.
    ENDIF.

    IF NOT <fs>-ofmnu IS INITIAL AND
        <fs>-ofmne NE <fs>-ofmnu.
      CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
        EXPORTING
          input    = <fs>-ofmnw
          unit_in  = <fs>-ofmne
          unit_out = <fs>-ofmnu
        IMPORTING
          output   = object_tab-ofmnw.
      object_tab-ofmne = <fs>-ofmnu.
    ENDIF.

* conversion exit func. loc.
    WRITE <fs>-tplnr_int TO object_tab-tplnr.

    IF NOT <fs>-stzhl IS INITIAL.
      READ TABLE object_tab INTO wa WITH KEY rueck = <fs>-rueck
                                           rmzhl = <fs>-stzhl.
      IF sy-subrc = 0.
        idx = sy-tabix + 1.
        INSERT object_tab INDEX idx.
      ELSE.
        APPEND object_tab.
      ENDIF.
    ELSE.
      APPEND object_tab.
    ENDIF.
  ENDLOOP.

*IF g_altern_act = g_x AND NOT strno_o[] IS INITIAL.
*  SORT object_tab BY rueck rmzhl.
*  DELETE ADJACENT DUPLICATES FROM object_tab COMPARING rueck rmzhl tplnr_int.
*ENDIF.

ENDFORM.                    " COMPLETE_OBJECT_TAB
*&---------------------------------------------------------------------*
*&      Form  GET_STATUS
*&---------------------------------------------------------------------*
*       get status text
*----------------------------------------------------------------------*
*      -->P_OBJNR  object number                                       *
*----------------------------------------------------------------------*
FORM get_status USING    p_objnr.
  DATA: sttxt LIKE rihafvr-sttxt,      " system status
        ustxt LIKE rihafvr-ustxt.      " user status

  CALL FUNCTION 'STATUS_TEXT_EDIT'
    EXPORTING
*     CLIENT           = SY-MANDT
      flg_user_stat    = 'X'
      objnr            = p_objnr
*     ONLY_ACTIVE      = 'X'
      spras            = sy-langu
    IMPORTING
*     ANW_STAT_EXISTING =
*     E_STSMA          =
      line             = sttxt
      user_line        = ustxt
    EXCEPTIONS
      object_not_found = 1
      OTHERS           = 2.

  MOVE sttxt TO object_tab-sttxt.
  MOVE ustxt TO object_tab-ustxt.
ENDFORM.                               " GET_STATUS

*&---------------------------------------------------------------------*
*&      Form  CONVERT_OUTPUT_TO_TIMEZONE_F87
*&---------------------------------------------------------------------*
*       Convert date and time fields of output to session time zone
*       only cinfirmation data must be converted because no date/time fields
*       from order/operation are used
*----------------------------------------------------------------------*
*      <--CS_AFRU        confirmation data
*      <--EV_NOT_VALID   Line not in output
*----------------------------------------------------------------------*
FORM convert_output_to_timezone_f87  CHANGING cs_afru       TYPE afru
                                              ev_not_valid  TYPE abap_bool.
  DATA: gb_badi_time_zone_iwoc TYPE REF TO badi_eam_tz_iwoc_core.
  BREAK-POINT ID eam_tzs_gen.

  TRY.
      GET BADI gb_badi_time_zone_iwoc.

    CATCH cx_badi_not_implemented.
      RETURN.
  ENDTRY.
*  IF gv_time_zone_active NE tzs1_active-yes.
**--- only if time zone support is active
*    RETURN.
*  ENDIF.
*
*  IF g_selmod = selmod_d.
**--- dark mode -> no conversion
*    RETURN.
*  ENDIF.

  CALL BADI gb_badi_time_zone_iwoc->convert_afru_sys2sess
    IMPORTING
      ev_not_valid = ev_not_valid
    CHANGING
      cs_afru      = cs_afru.

ENDFORM.                    " CONVERT_OUTPUT_TO_TIMEZONE_F87